[
    {
        "type": "thought",
        "content": "A custom FTP service is running on the the port 12012 of the target, we have to find a way to bypass the authentication mechanism.\n\nThe binary is an ELF 64-bit, with a simple static analysis we find out that to authenticate a user the FTP service compare the username with the string \"blankwall\" and generate a 32 bits hash for the submitted password, this hash must equal to the value 0xD386D209 to grant access to the FTP commands.\nUnderstanding the function responsible for the hash generation is quite simple, here is what the disassembly looks like.\n\nhash proc\ninput = qword -0x18\nindex = dword -0x08\ncheck = dword -0x04\n    push    rbp\n    mov     rbp, rsp\n    mov     [rbp + input], rdi\n    mov     [rbp + result], 0x1505\n    mov     [rbp + index], 0x00\n    jmp     loop_start\n\nloop_continue:\n    mov     eax, [rbp + result]\n    shl     eax, 0x05\n    mov     edx, eax\n    mov     eax, [rbp + result]\n    lea     ecx, [rdx + rax]\n    mov     eax, [rbp + index]\n    movsxd  rdx, eax\n    mov     rax, [rbp + input]\n    add     rax, rdx\n    movzx   eax, byte [rax]\n    movsx   eax, al\n    add     eax, ecx\n    mov     [rbp + result], eax\n    add     [rbp + index], 0x01\n\nloop_start:\n    mov     eax, [rbp + index]\n    movsxd  rdx, eax\n    mov     rax, [rbp + input]\n    add     rax, rdx\n    movzx   eax, byte [rax]\n    test    al, al\n    jnz     loop_continue\n\n    mov     eax, [rbp + result]\n    pop     rbp\n    retn\nhash endp\nBasically what we need to do now is to find a string for which the hash function will generate the value 0xD386D209.\nTo do so we used Z3 The Theorem Prover, it's an excellent tool for key generation algorithms.\n\nFirst we have to transcribe the hash algorithm to Python. Note that although this a 64 bit binary we can fit the algorithm of the hash function on 32 bit registers."
    },
    {
        "type": "execution",
        "content": "#!/usr/bin/env python\nfrom z3 import *\n\ndef display_model(m):\n    block = {}\n    for x in m:\n        if \"b\" in str(x):\n            block[ord(str(x)[-1:])] = int(str(m[x]))\n\n    password = \"\".join(map(chr, block.values()))\n    print password\n\ndef get_models(F):\n    s = Solver()\n    s.add(F)\n    while True:\n        if s.check() == sat:\n            m = s.model()\n            display_model(m)\n            block = []\n            for d in m:\n                if d.arity() > 0:\n                    raise Z3Exception(\"uninterpreted functions are not supported\")\n                c = d()\n                if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT:\n                    raise Z3Exception(\"arrays and uninterpreted sorts are not supported\")\n                block.append(c != m[d])\n            s.add(Or(block))\n        else:\n            break\n\ndef is_alphanum(x):\n    return Or(And(x >= 0x41, x <= 0x5a), And(x >= 0x61, x <= 0x7a), And(x >= 0x30, x <= 0x39))\n\ndef calculate(password):\n    ret, ecx, edx = BitVecs(\"ret ecx edx\", 32)\n    i = BitVec(\"i\", 8)\n    ret = 0x1505\n\n    for i in range(len(password)):\n        edx = (ret << 5)\n        ecx = (edx + ret)\n        ret = (password[i] + ecx)\n\n    return ret\n\nif __name__ == \"__main__\":\n    F = []\n    length = 10\n    hash = BitVec(\"hash\", 32)\n    password = [BitVec(\"b{0:02d}\".format(i), 32) for i in range(length)]\n\n    F.extend([is_alphanum(password[i]) for i in range(length)])\n    F.extend([\n        hash == 0xD386D209,\n        calculate(password) == hash\n    ])\n\n    get_models(F)"
    },
    {
        "type": "thought",
        "content": "We decided to generate an alphanumeric string of 10 chars, in a very short amount of time some valid passwords will satisfy our conditions and appear in the terminal. Now getting the flag is trivial, a simple netcat command would do the job but it's more explicit in Python.\nThe script sends the username, the password and the RDF command which order the server to read the file containing the flag."
    },
    {
        "type": "execution",
        "content": "#!/usr/bin/env python\nimport sys\nimport socket\n\nHOST = \"54.175.183.202\"\nPORT = 12012\n\nusername = \"blankwall\"\npassword = \"erh6clKoae\"\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((HOST, PORT))\ns.recv(1024)\n\ns.send(\"USER \" + username + \"\\n\")\ns.recv(1024)\n\ns.send(\"PASS \" + password)\ns.recv(1024)\ns.recv(1024)\n\ns.send(\"RDF\")\ndata = s.recv(1024)\nsys.stdout.write(data)\n\ns.close()"
    }
]