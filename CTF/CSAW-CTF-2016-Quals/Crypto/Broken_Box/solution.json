[
    {
        "type": "thought",
        "content": "In these two challenges we were given black-box access to a RSA signing (decryption oracle). We need to decrypt a given flag, but the oracle allows only to sign values in range 0-9999. Moreover, sometimes it gives different signatures for same values, because there are some faults due to &#8220;hardware errors&#8221; mentioned in the description.The simplest fault attacks on RSA are attacks on RSA-CRT, where by using gcd we can factor the modulus. However we tried to apply them and they failed. Therefore, it is probably not RSA-CRT scheme there.\n\nBy sampling signatures of, let\u2019s say number 2, we can find that there are about 1000 unique values. It matches the size of the modulus in bits. Then it may be that the server flips some single bit of the secret exponent sometimes. There was a similar challenge already at this year\u2019s Plaid CTF, but there we didn\u2019t get enough bits.\nHere&#8217;s how we can check our hypothesis: if we get $s = 2^{d \\oplus 2^k} \\mod{N}$ for some $k$, we can guess $k$ and check if $(s\\times 2^{\\pm 2^k})^e \\mod N = 2$. If this condition holds, then we learn one bit from the secret exponent, depending on the sign of $\\pm k$.\nIndeed, the following script waits to collect all unknown bits and prints the flag for the first part:"
    },
    {
        "type": "execution",
        "content": "import ast\nfrom sock import Sock\nfrom libnum import *\n \nN = 172794691472052891606123026873804908828041669691609575879218839103312725575539274510146072314972595103514205266417760425399021924101213043476074946787797027000946594352073829975780001500365774553488470967261307428366461433441594196630494834260653022238045540839300190444686046016894356383749066966416917513737\nE = 0x10001\nsig_correct = 22611972523744021864587913335128267927131958989869436027132656215690137049354670157725347739806657939727131080334523442608301044203758495053729468914668456929675330095440863887793747492226635650004672037267053895026217814873840360359669071507380945368109861731705751166864109227011643600107409036145468092331\nC = int(open(\"flag.enc\").read())\n \nf = Sock(\"crypto.chal.csaw.io 8002\")\nf.send_line(\"2\")\nf.read_until(\"no\")\n \ndef sign(val):\n    f.send_line(\"yes\")\n    f.send_line(\"%d\" % val)\n    sig, mod = map(int, f.read_until_re(r\"signature:(\\d+), N:(\\d+)\\s\").groups())\n    assert mod == N\n    return sig\n \ntry:\n    bits, vals = ast.literal_eval(open(\"dump\").read())\nexcept:\n    bits, vals = {}, []\nvals = set(vals)\n \nprint len(bits), \"known bits\"\nnum = 2\n \ngs = {\n    num * pow(num, (1 << e) * E, N) % N\n    : e for e in xrange(0, 1030)\n}\ngsi = {\n    (num * invmod(pow(num, (1 << e) * E, N), N)) % N\n    : e for e in xrange(0, 1030)\n}\n \nwhile 1:\n    if len(bits) >= 1024:\n        print len(bits), \"known\", set(range(1025)) - set(bits), \"unknown\"\n        d = sum(1 << e for e, b in bits.items() if b)\n        print \"Try:\", `n2s(pow(C, d, N))`\n \n    sig = sign(num)\n    if sig in vals:\n        continue\n    vals.add(sig)\n    test = pow(sig, E, N)\n    if test in gs:\n        bits[gs[test]] = 0\n        print \"bit[%d] = 0\" % gs[test]\n    if test in gsi:\n        bits[gsi[test]] = 1\n        print \"bit[%d] = 1\" % gsi[test]\n    open(\"dump\",\"w\").write(`(bits, list(vals))`)\n    print len(bits), \"known bits\""
    }
]