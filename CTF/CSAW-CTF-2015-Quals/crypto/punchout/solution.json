[
    {
        "type": "thought",
        "content": "The first of the two challenging crypto challenges this year at CSAW, punchout, gave three binary blobs that were supposedly taken from IBM system/360 punch cards, and encrypted using technology of the time. So lets begin with some research on technologies of that time. The wikipedia page indicates that the system used EBCDIC encoding instead of ascii encoding. Unfortunately, just running the files through a straight EBCDIC decoder proved fruitless. Further analysis indicated that real encryption was used (unlike a few of the earlier challenges i.e. de-base64 this string!)\n\nAccording to the cryptography timeline, Feistel ciphers were conceived of in 1974, almost a decade after the time given for this challenge (1965). The ciphers that did exist - ciphers like KW-26 - relied on key extent ion to get a long stream of bits derived from the key, which are then xor'd against the plaintext. Unfortunately there were many similar ciphers, and we did not know which one was used. Further, finding out the mechanism for the cipher wasn't an easy task ether, preventing us from implementing them.\n\nWhat we assumed was that there would be some random sequence of bits xor'd against the plain text and that key used to generate this sequence would be the same between each file. This allowed us to treat it as a reuse of a one time pad, for which the attack is known.\n\nWhen you reuse a one time pad, the two cipher texts are both P1 XOR K and P2 XOR K. When you xor the two cipher texts together, the resulting blob is P1 XOR P2. There were a suspicius amount of upper case characters: .N.t.....2DA..U....U......N.A...NF..T.O..O.I..ET.......M...A..T.\n\nAt this point, you make guesses at common english words, such as 'the', 'and', 'because', etc, and xor them with your xor'd cipher texts. If at any point the result looks like an english word, you probably guessed correctly for that position.\n\nBecause we have a third file xor'd with the same key, we can use what we think the key is (the plaintext xor'd with the cipher text), against it to find which ciphertext the plaintext came from, and solidify the key. Now we have three plaintexts to guess at."
    },
    {
        "type": "execution",
        "content": "def isinwhat(x, f1, f2, f3, i):\n    key1 = xor(x, f1[i:i+len(x)])\n    key2 = xor(x, f2[i:i+len(x)])\n    key = ''\n    if checkgood(xor(key1, f3[i:i+len(key1)])):\n        key = key1\n    elif checkgood(xor(key2, f3[i:i+len(key2)])):\n        key = key2\n    else:\n        return"
    },
    {
        "type": "thought",
        "content": "We crafted a script around this to automate the guessing, then set half the team to guessing at cribs. This involved much yelling of found strings. We found the source texts of 'The History of Java, volume 1' and 'The Rainy Day Book' on google books, and got the remaining text including the flag from there."
    },
    {
        "type": "execution",
        "content": "#!/usr/bin/python                                                                                                                                                                                                                                                                                                              \n\nimport sys, struct, time\nimport ebcdic\n\n\n#creates an empty file of size null bytes                                                                                                                                                                                                                                                                                      \ndef createFiles():\n    hFile = open(\"./1.dec\",\"w\")\n    hFile.write(\"\\x00\"*1024)\n    hFile.close()\n    hFile = open(\"./2.dec\",\"w\")\n    hFile.write(\"\\x00\"*1024)\n    hFile.close()\n    hFile = open(\"./3.dec\",\"w\")\n    hFile.write(\"\\x00\"*1024)\n    hFile.close()\n\n\nif len(sys.argv) > 1 and sys.argv[1] == \"!create\":\n    createFiles()\n    sys.exit(0)\n\n#writes content to offset from beginning of file                                                                                                                                                                                                                                                                               \ndef writeFile(number, content, offset):\n\n        hFile = open(\"./%d.dec\"%number,\"r\").read()\n        newfile = hFile[:offset] + content + hFile[offset+len(content):]\n        f = open(\"./%d.dec\"%number, 'w')\n        f.write(newfile)\n        f.close()\n\ndef checkgood(data):\n    for i in data:\n        if ord(i) <0x4a and ord(i) != 0x40:\n            return 0\n        elif ord(i) > 0x50 and ord(i) < 0x5a:\n            return 0\n        elif ord(i) > 0x61 and ord(i) < 0x6a:\n            return 0\n        elif ord(i) > 0x6f and ord(i) < 0x79:\n            return 0\n        elif ord(i) == 0x80:\n            return 0\n        elif ord(i) > 0x89 and ord(i) < 0x91:\n            return 0\n        elif ord(i) > 0x99 and ord(i) < 0xa1:\n            return 0\n        elif ord(i) > 0xa9 and ord(i) < 0xc0:\n            return 0\n        elif ord(i) > 0xc9 and ord(i) < 0xd0:\n            return 0\n        elif ord(i) > 0xd9 and ord(i) < 0xe0:\n            return 0\n        elif ord(i) == 0xe1:\n            return 0\n        elif ord(i) > 0xe9 and ord(i) < 0xf0:\n            return 0\n        elif ord(i) > 0xf9:\n            return 0\n    return 1\n\ndef xor(s1, s2):\n    l = min(len(s1), len(s2))\n    ns = ''\n    for i in range(l):\n        ns += chr(ord(s1[i]) ^ ord(s2[i]))\n    return ns\n\n\ndef q(x):\n    return struct.pack(\"<I\", x)\n\n\ndef p(x):\n    return struct.unpack(\"<I\", x)[0]\n\nsuccesses = []\n\ndef isinwhat(x, f1, f2, f3, i):\n    key1 = xor(x, f1[i:i+len(x)])\n    key2 = xor(x, f2[i:i+len(x)])\n    key = ''\n    if checkgood(xor(key1, f3[i:i+len(key1)])):\n        key = key1\n    elif checkgood(xor(key2, f3[i:i+len(key2)])):\n        key = key2\n    else:\n        return\n\n    print(len(successes))\n    sys.stdout.write(\"In File 1 at offset %d: %s\\n\"%(i, xor(key, f1[i:i+len(key)]).decode('ebcdic-cp-us')))\n    sys.stdout.write(\"In File 2 at offset %d: %s\\n\"%(i, xor(key, f2[i:i+len(key)]).decode('ebcdic-cp-us')))\n    sys.stdout.write(\"In File 3 at offset %d: %s\\n\"%(i, xor(key, f3[i:i+len(key)]).decode('ebcdic-cp-us')))\n    sys.stdout.write(\"\\n\")\n    successes.append((i,\n                      xor(key, f1[i:i+len(key)]).decode('ebcdic-cp-us') ,\n                      xor(key, f2[i:i+len(key)]).decode('ebcdic-cp-us') ,\n                      xor(key, f3[i:i+len(key)]).decode('ebcdic-cp-us')))\n\ncrib = raw_input(\"Enter crib: \").encode('ebcdic-cp-us')\n\nfile1=open(\"1\", 'r').read()\nfile2=open(\"2\", 'r').read()\nfile3=open(\"3\", 'r').read()\nxord=xor(file1, file2)\nxor2=xor(file1, file3)\n\nblah=[]\nfor i in range(0, len(file3)-len(crib)):\n    h1=xor(crib, xord[i:i+len(crib)])\n    h2=xor(crib, xor2[i:i+len(crib)])\n    if checkgood(h1) or checkgood(h2):\n        isinwhat(crib, file1, file2, file3, i)\n\nnumbers = [int(x) for x in raw_input(\"Enter indicies: \").split(' ')]\nfor number in numbers:\n    writeFile(1, successes[number][1], successes[number][0])\n    writeFile(2, successes[number][2], successes[number][0])\n    writeFile(3, successes[number][3], successes[number][0])"
    }
]