[
    {
        "type": "thought",
        "content": "The task shows a webpage with Neo going to Oracle. There is a html form with some base64 encoded data. Decoding gives some random 80 bytes blob. Once every few seconds the data changes, most likely there is embedded timestamp. If we provide our own base64 data in the form the page says that AES decryption failed. This all points to Padding Oracle Attack - vulnerability which allows us to decode n-1 blocks of block cipher ciphertext in CBC mode.\n\nIn CBC mode the plaintext is XORed with previous block ciphertext. This means that a change in a single byte of ciphertext will cause all bytes on corresponding positions in next blocks to be decrypted incorrectly, since they will be XORed with a wrong value. What we want to achieve in the attack is to exploit how decryption handles padding. In PKCS7 padding the last byte of decrypted data defines padding. It's a number which says how many padding bytes there are and also what value each of them holds. For example if there is 3 byte padding the 16 byte block would be XXXXXXXXXXXXX0x30x030x3.\n\nIf the padding is not formed correctly we will get decryption error, since it means the data were tamered with. What we want to achieve with our attack is to try to guess the plaintext byte by attempting to \"transform\" it into padding.\n\nLet's assume we have 2 blocks of ciphertext. If we change the last byte of the first block this value will be XORed with decrypted last byte of the second block. We changed it so it won't get the \"proper\" value anymore, so the padding will be broken for sure... unless the value will become 0x1, which is a correct padding indicator! If the value became 0x1 this means that our_changed_byte XOR decrypted_byte = 0x1 and this means that decrypted_byte = our_changed_byte XOR 0x1!\n\nSo if for a certain value we won't get decryption error this means we successfully decoded the last byte of ciphertext.\n\nNow we can extend this to more bytes - to recover the byte k-1 we need to change the last byte to 0x2 and if we find the byte with no error in decryption it means that the xored value is also 0x2.\n\nThis of course won't let us recover the first block, but this can't be helped, unless some special conditions are met. In some cases the IV is placed as the first block of plaintext before encryption, and if this is the case, we could recover the IV as well. In our case we had no knowledge of the way IV was handled, and if the IV is needed for us or not. We assumed we don't need it and it turned out to be the right guess."
    },
    {
        "type": "execution",
        "content": "import base64\nimport re\nimport urllib\nimport urllib2\nimport sys\nfrom binascii import hexlify, unhexlify\nfrom itertools import cycle\n\n# most of the code comes from https://github.com/mpgn/Padding-oracle-attack/blob/master/exploit.py\n'''\n    Padding Oracle Attack implementation of this article https://not.burntout.org/blog/Padding_Oracle_Attack/\n    Check the readme for a full cryptographic explanation\n    Author: mpgn <martial.puygrenier@gmail.com>\n    Date: 2016\n'''\n\n\ndef oracle(data):\n    url = \"http://crypto.chal.csaw.io:8001/\"\n    bytes_data = long_to_bytes(int(data, 16))\n    values = {'matrix-id': base64.b64encode(bytes_data)}\n    data = urllib.urlencode(values)\n    req = urllib2.Request(url, data)\n    response = urllib2.urlopen(req)\n    the_page = response.read()\n    if \"exception\" in the_page:\n        return False\n    else:\n        return True\n\n\ndef split_len(seq, length):\n    return [seq[i:i + length] for i in range(0, len(seq), length)]\n\n\n''' create custom block for the byte we search'''\n\n\ndef block_search_byte(size_block, i, pos, l):\n    hex_char = hex(pos).split('0x')[1]\n    return \"00\" * (size_block - (i + 1)) + (\"0\" if len(hex_char) % 2 != 0 else '') + hex_char + ''.join(l)\n\n\n''' create custom block for the padding'''\n\n\ndef block_padding(size_block, i):\n    l = []\n    for t in range(0, i + 1):\n        l.append((\"0\" if len(hex(i + 1).split('0x')[1]) % 2 != 0 else '') + (hex(i + 1).split('0x')[1]))\n    return \"00\" * (size_block - (i + 1)) + ''.join(l)\n\n\ndef hex_xor(s1, s2):\n    return hexlify(''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(unhexlify(s1), cycle(unhexlify(s2)))))\n\n\ndef run(ciphertext, size_block):\n    ciphertext = ciphertext.upper()\n    found = False\n    valid_value = []\n    result = []\n    len_block = size_block * 2\n    cipher_block = split_len(ciphertext, len_block)\n    if len(cipher_block) == 1:\n        print \"[-] Abort there is only one block\"\n        sys.exit()\n    for block in reversed(range(1, len(cipher_block))):\n        if len(cipher_block[block]) != len_block:\n            print \"[-] Abort length block doesn't match the size_block\"\n            break\n        print \"[+] Search value block : \", block, \"\\n\"\n        for i in range(0, size_block):\n            for ct_pos in range(0, 256):\n                if ct_pos != i + 1 or (\n                                len(valid_value) > 0 and int(valid_value[len(valid_value) - 1], 16) == ct_pos):\n                    bk = block_search_byte(size_block, i, ct_pos, valid_value)\n                    bp = cipher_block[block - 1]\n                    bc = block_padding(size_block, i)\n                    tmp = hex_xor(bk, bp)\n                    cb = hex_xor(tmp, bc).upper()\n                    up_cipher = cb + cipher_block[block]\n                    response = oracle(up_cipher)\n                    exe = re.findall('..', cb)\n                    discover = ''.join(exe[size_block - i:size_block])\n                    current = ''.join(exe[size_block - i - 1:size_block - i])\n                    find_me = ''.join(exe[:-i - 1])\n                    sys.stdout.write(\n                        \"\\r[+] Test [Byte %03i/256 - Block %d ]: \\033[31m%s\\033[33m%s\\033[36m%s\\033[0m\" % (\n                            ct_pos, block, find_me, current, discover))\n                    sys.stdout.flush()\n                    if response:\n                        found = True\n                        value = re.findall('..', bk)\n                        valid_value.insert(0, value[size_block - (i + 1)])\n                        print ''\n                        print \"[+] Block M_Byte : %s\" % bk\n                        print \"[+] Block C_{i-1}: %s\" % bp\n                        print \"[+] Block Padding: %s\" % bc\n                        print ''\n                        bytes_found = ''.join(valid_value)\n                        print '\\033[36m' + '\\033[1m' + \"[+]\" + '\\033[0m' + \" Found\", i + 1, \"bytes :\", bytes_found\n                        print ''\n                        break\n            if not found:\n                print \"\\n[-] Error decryption failed\"\n                result.insert(0, ''.join(valid_value))\n                hex_r = ''.join(result)\n                print \"[+] Partial Decrypted value (HEX):\", hex_r.upper()\n                padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n                print \"[+] Partial Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n                sys.exit()\n            found = False\n        result.insert(0, ''.join(valid_value))\n        valid_value = []\n    print ''\n    hex_r = ''.join(result)\n    print \"[+] Decrypted value (HEX):\", hex_r.upper()\n    padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n    print \"[+] Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n\n\ndef long_to_bytes(flag):\n    flag = str(hex(flag))[2:-1]\n    return \"\".join([chr(int(flag[i:i + 2], 16)) for i in range(0, len(flag), 2)])\n\n\ndef bytes_to_long(data):\n    return int(data.encode('hex'), 16)\n\n\nct = base64.b64decode(\n    \"9aMTHPS1oP9VQA9Hxz5mGSIRuOVSspcQrGJlBYUoZIUhmur9X1B8hJJFeR48trScLtToNPCeWZiSz4Qit3KvsHlv0Xqy8rHREJUvYNbff1I=\")\nhexlified = bytes_to_long(ct)\nrun(hex(hexlified)[2:-1], 16)"
    }
]